 

# NowCoder
剑指Offer 66题刷题笔记

Table of Contents
=================

   * [NowCoder]()
      * [数组]()
         * [数组查找]()
            * [1. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/二维数组的查找.cpp">二维数组的查找</a>]()
            * [3. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/数组中重复的数字.cpp">数组中重复的数字</a>]()
            * [4. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/连续子数组的最大和.cpp">连续子数组的最大和</a>]()
            * [5. [旋转数组的最小数字]]()
            * [6. [数组中出现次数超出一半的数字]]()
            * [7. [数组中的逆序对]]()
         * [数组排序]()
            * [8. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/把数组排成最小的数.cpp">把数组排成最小的数</a>]()
            * [9. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/调整数组顺序使奇数位于偶数前面.cpp">调整数组顺序使奇数位于偶数前面</a>]()
         * [数组其他]()
            * [10. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/构建乘积数组.cpp">构建乘积数组</a>]()
            * [11. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/顺时针打印矩阵.cpp">顺时针打印矩阵</a>]()
            * [12. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/矩阵中的路径.cpp">矩阵中的路径</a>]()
      * [字符串]()
            * [1. <a href="https://github.com/JINGbw/NewCoder/blob/master/字符串/替换空格.cpp">替换空格</a>]()
            * [2. [正则表达式匹配]]()
            * [3. [表示数值的字符串]]()
            * [4. [第一个只出现一次的字符位置（字符串中第一个不重复的字符）]]()
            * [5. <a href="https://github.com/JINGbw/NewCoder/blob/master/字符串/字符流中第一个不重复的字符.cpp">字符流中第一个不重复的字符</a>]()
            * [6. <a href="https://github.com/JINGbw/NewCoder/blob/master/字符串/字符串的排列（全排列）.cpp">字符串的排列（全排列）</a>]()
            * [7. [翻转字符串]]()
            * [8. [左旋转字符串]]()
            * [9. [最长不含重复字符的子字符串]]()
      * [链表]()
         * [链表结点]()
            * [1. [链表中倒数第k个结点]]()
            * [2. [链表中环的入口节点]]()
            * [3. [两个链表的第一个公共结点]]()
            * [4. <a href="https://github.com/JINGbw/NewCoder/blob/master/链表/删除链表中重复的结点.cpp">删除链表中重复的结点</a>]()
         * [链表打印/转换]()
            * [5. [从尾到头打印链表]]()
            * [6. <a href="https://github.com/JINGbw/NewCoder/blob/master/链表/反转链表.cpp">反转链表</a>]()
            * [7. [二叉搜索树与双向链表]]()
            * [8. [合并两个排序的链表]]()
            * [9. [链表回文结构]]()
            * [10. [把字符串转换成整数(Atoi)]]()
            * [11. [复杂链表的复制]]()
      * [树]()
         * [二叉树遍历，打印]()
            * [1. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/按之字形顺序打印二叉树.cpp">按之字形顺序打印二叉树</a>]()
            * [2. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/把二叉树打印成多行.cpp">把二叉树打印成多行（二叉树的层次遍历）</a>]()
            * [3. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/从上往下打印二叉树.cpp">从上往下打印二叉树</a>]()
         * [二叉树判断]()
            * [4. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/对称的二叉树.cpp">对称的二叉树</a>]()
            * [5. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/平衡二叉树.cpp">平衡二叉树</a>]()
            * [6. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/树的子结构.cpp">树的子结构</a>]()
            * [7. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/二叉搜索树的后序遍历.cpp">二叉树的后序遍历序列</a>]()
         * [二叉树结点相关]()
            * [8. <a href="https://github.com/JINGbw/NewCoder/blob/master/树/二叉搜索树的第k个结点.cpp">二叉搜索树的第k个结点</a>]()
            * [9. [二叉树的中序遍历下一个结点]]()
         * [根据输入重建二叉树 （输入数组，输出二叉树 ）]()
            * [10. [重建二叉树]]()
         * [二叉树变换（输入二叉树，输出二叉树/序列 ）]()
            * [11.  <a href="https://github.com/JINGbw/NewCoder/blob/master/树/二叉树的镜像.cpp">二叉树的镜像</a>]()
            * [12. [二叉搜索树与双向链表]]()
            * [13. [序列化二叉树]]()
         * [二叉树信息]()
            * [14 <a href="https://github.com/JINGbw/NewCoder/blob/master/树/二叉树的深度.cpp">二叉树的深度</a>]()
            * [15. <a href="https://github.com/JINGbw/LeetcodeLeetcode/blob/master/二叉树/113.路径总和.cpp">二叉树中和为某一值的路径</a>]()
      * [栈和队列]()
            * [1. [用两个栈实现队列]]()
            * [2. <a href="https://github.com/JINGbw/NewCoder/blob/master/栈和队列/包含min函数的栈.cpp">包含min函数的栈</a>]()
         * [3. <a href="https://github.com/JINGbw/NewCoder/blob/master/栈和队列/栈的压入、弹出序列.cpp">栈的压入、弹出序列</a>]()
      * [位运算]()
            * [1. [二进制中1的个数]]()
            * [2. [判断二进制中0的个数]]()
            * [3. [二进制高位连续0的个数]]()
      * [数据流]()
            * [- [数据流中的中位数]]()
            * [- [字符流中只出现一次的字符]]()
      * [递归和循环]()
            * [1. [斐波那契数列]]()
            * [2. [跳台阶]]()
            * [3. [变态跳台阶]]()
            * [4. [矩形覆盖]]()
      * [回溯法]()
            * [1. <a href="https://github.com/JINGbw/NewCoder/blob/master/数组/矩阵中的路径.cpp">矩阵中的路径</a>]()
            * [2. [机器人的运动范围]]()
      * [其他]()
            * [1. <a href="/JINGbw/NewCoder/blob/master/从1到n中的整数中1出现的次数">整数中1出现的次数</a>]()
            * [2. 扑克牌顺子]()
            * [3. 孩子们的游戏（圆圈中剩下的数）]()
            * [4. 替换空格]()
            * [5. 数值的整数次方]()
            * [6. 顺时针打印矩阵]()
            * [7. 最小的k个数(堆排序)]()
            * [8. 丑数]()
      * [c  ]()


## 数组

### 数组查找 

#### 1. [二维数组的查找](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE.cpp)

- 题目：二维数组从左到右依次变大，从上到下依次变大，找到目标数字
- 思路：法一：利用二分法找到该数所在的行，再用二分法找到这个数。法二：从左下角或者右上角开始找，可以根据Target与当前元素的大小关系来缩小查找区间


#### 3. [数组中重复的数字](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.cpp)
- 题目：找到数组中任意一个重复的数字
- 思路：如果第i个数不等于i,就把第i个数换到i的位置去，如果第i个数那个数的位置 等于那个数，就说明找到了重复的数字


#### 4. [连续子数组的最大和](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)

题目：找到给定数组中连续子数组的最大和
- 思路：动态规划的状态转移方程：
    - dp[i] = array[0] , (i = 0 ) 
    - dp[i] = max(dp[i-1]+array[i],array[i]); (i = 1,2 ,3 ... n-1) 

- （力扣）上有一题是求最长上升子序列的长度，不要搞混了 


#### 5. [旋转数组的最小数字]
- 相关：[在旋转数组中寻找目标数字]

#### 6. [数组中出现次数超出一半的数字]
- 相关：[数组中出现次数等于一半的数字]

#### 7. [数组中的逆序对]
- 题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007


### 数组排序

#### 8. [把数组排成最小的数](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp)

- 题目：把数组（int类型）里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个
- 思路：1.重新定义排序函数中调用的比较函数cmp 并排序 2. 将排好序的数组拼接起来返回
 
   
#### 9. [调整数组顺序使奇数位于偶数前面](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp)

- 题目：调整数组中数字的顺序，使奇数在偶数前面
- 思路：1.奇数放在前半部分，从原来数组的后面开始找 ,从前面插入到双端队列 2.偶数放在后半部分，从前开始找，插入双端队列的后面 

### 数组其他
#### 10. [构建乘积数组](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.cpp)

- 题目：给定数组A[0,1,...n-1]，要求构建B[0,1,...n-1],其中B的元素B[i] = A[0]A[1]...A[i-1]A[i+1]...A[n-1]。要求不能使用除法
- 思路：循环B数组两遍，将B中结果拆成两部分乘积，一部分是下三角形，一部分是上三角形。
    -  B[0] = 1 ,i从1到n-1 ,$B[i]=B[i-1]* A[i-1]$ 
    -  i从n-2到0 ，$ tmp*= A[i+1], B[i] = B[i]* tmp$
 


#### 11. [顺时针打印矩阵](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp)

- 题目：按照顺时针的顺序打印出矩阵中的每一个数字 
- 思路：
    1. 从左到右
    2. 从上到下 判断跳出条件 top==bottom
    3. 从右到左 right == left
    4. 从下到上 top = bottom-1 
- 注意循环截止条件 （3.4.的时候考虑）(只有一行或者一列的情况)

#### 12. [矩阵中的路径](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)
- 题目：矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。
- 思路：使用一个bool矩阵记录矩阵的当前位置是否走过，使用一个变量pathlength记录走到了字符串的哪个位置 。
    -  对于数组中的每一个位置，都调用递归函数，从数组第row,col这个位置开始找，是否有字符串第pathlenhgth(包含这个位置，及以后的子串)
    -  如果当前位置没有超出范围，且当前位置没走过，且当前位置等于字符串pathlength元素，进入函数 
- 注：如果形参未引用，那么实参不能在传参时进行加减。需要先计算好再传入


## 字符串

#### 1. [替换空格](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.cpp)

- 题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”
- 思路：1. 遍历字符串，统计字符串的空格个数和非空格个数，得到替换后的长度      2. 从后往前替换，如果是空格就换为“%20”

#### 2. [正则表达式匹配]

#### 3. [表示数值的字符串]

#### 4. [第一个只出现一次的字符位置（字符串中第一个不重复的字符）]

- 题目：找到字符串中一个只出现一次的字符位置
- 思路：使用哈希表 （或者长度为256的数组做哈希表） 1. 遍历一遍，使用哈希表记录每个字符出现的次数 2. 再遍历一遍，如果只出现一次，返回

#### 5. [字符流中第一个不重复的字符](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.cpp)
- 题目：找到字符流中第一个不重复的字符（两个函数 ，一个用于向字符流中插入字符，一个用于找到第一个不重复的字符）
- 思路：1. 使用string s 记录该字符流 2. 使用哈希表（长度为256），初始化为-1，如果出现一次，occur[i]记录为它再字符流中的位置，没有出现过是-1 ，出现超过一次，出现过多次记录为-2。

（还有字符串中第一个不重复的字符 用哈希表来做（长度为256的数组，记录每个字符出现的次数））O(n)

#### 6. [字符串的排列（全排列）](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%89.cpp)
- 题目：输入字符串求全排列
- 思路：递归让每个数字当第一个，循环截止条件：递归到了最后一个数字/每次递归结束后再换回来。
    - 递归的条件：1. 当前数字是第一个或者当前值与第一个值不等才会交换和递归
 
#### 7. [翻转字符串]

- 题目：将英文句子中的单词顺序翻转，但是单词内字符的顺序不变
- 思路：1. 在原字符串后加空格，作为标记，以空格为标记，翻转每个子单词 2. 删除单词，翻转整个字符串 

#### 8. [左旋转字符串]

- 题目：左旋转字符串ROL ，将string str左移n位 
- 思路1 ：相当于在原来的字符串后面再加上一个原来的字符串，取新字符串的 .substr(n, len);//n= n%len 
- 思路2 ：利用上面翻转字符串的思路，先翻转前面n个，再翻转整个字符串。

#### 9. [最长不含重复字符的子字符串]

## 链表

### 链表结点

#### 1. [链表中倒数第k个结点]
- 题目：输入一个链表，输出该链表中倒数第k个结点。
- 思路：一个指针先向前走k-1步，两个指针再一起向前走，前面的指向空了，就找到了倒数第k个结点。

#### 2. [链表中环的入口节点]
- 题目：找到链表中环的入口节点
- 思路：
    - 法一：1. 使用两个指针，一个比另一个速度快一步，两个一起向前走，如果相遇，相遇点一定在环中。2. 使用两个指针，一个从相遇处开始走，一个从头节点开始走，如果再次相遇，相遇点就是环的入口
    - 法二：1.同上 2. 在第一步相遇后，使用一个节点记录相遇处，另一个节点在环中绕一圈，就可以得到环的长度。3. 得到环的长度后，使用两个指针，一个先走环的长度，两个指针再一起走。
    
#### 3. [两个链表的第一个公共结点]
- 题目：输入两个链表，找出它们的第一个公共结点。
- 思路：因为都是单链表，两个链表一旦相交就不会分开了。
    - 法一：1. 先分别遍历两个链表，得到两个链表的长度 2. 比较长的链表先走（两个链表长度的差值）再一起向前走，直到相遇
    - 法二：1. 使用两个指针，一个从链表A开始走，如果走到了尾部，就从B的头部重新开始访问B 。另一个从链表B开始走，如果走到尾部就从链表A的头部重新开始访问。当两个指针相遇的时候，就是两个链表的第一个公共结点。 
    
#### 4. [删除链表中重复的结点](https://github.com/JINGbw/NewCoder/blob/master/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp)
- 题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 
- 思路：使用三个指针，pre,cur,next ,pre指向不重复的最后一个，cur指向重复的第一个，next指向重复的最后一个
     - 如果cur和它下一个一样，就用next向后找，走到最后一个重复的节点。
     - 如果cur是第一个节点，就删除cur到next,将指向第一个元素的指针指向pHead  
         
    
### 链表打印/转换 

#### 5. [从尾到头打印链表]
- 题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
- 思路：法一：使用栈或者递归 
    - 法二：使用头插法构建逆序链表
    
#### 6. [反转链表](https://github.com/JINGbw/NewCoder/blob/master/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp)
- 题目：原地翻转链表 输出新链表的表头 
- 思路：使用四个指针 pre,cur,next,newhead 

- [反转链表的一部分](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E9%93%BE%E8%A1%A8/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II.cpp)
- 题目：反转链表中的部分节点，使用一趟扫描完成反转（第m个到第n个）
- 思路：使用三个指针pre,cur,nt 反转链表 。时间复杂度：O(N)。空间复杂度：O(1)
    -  一个指针向前走m-1步走到第一个待翻转的结点。pre指向待反转的前一个结点
    -  cur指向待反转的第一个节点 ， 一次翻转 cur 和 next 两个 ，一直到n
    -  修改每个指针的->next 先修改cur,再next，最后Pre 
    

#### 7. [二叉搜索树与双向链表]



#### 8. [合并两个排序的链表]
- 题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
- 思路：1. 如果一个为空就直接返回另一个 2. 利用递归的方法，两个链表头节点中比较小的，下一个结点接上递归调用剩下的。

#### 9. [链表回文结构]

#### 10. [把字符串转换成整数(Atoi)]

#### 11. [复杂链表的复制]

- 题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。next指针，random指针，val 
- 思路：1. 在原来链表每个节点后面插入复制的节点，复制next和val 2. 复制random 3. 将一个链表拆成两个 

## 树

1. 完全二叉树：堆就是由完全二叉树组成的，前n-1层全满，第n层只有右边可以是空的。
2. 满二叉树： 树中每个分支结点都有2棵非空子树。
3. 二叉搜索树： 
### 二叉树遍历，打印 

#### 1. [按之字形顺序打印二叉树](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
- （类似层次遍历）
- 题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
- 思路：使用两个栈stack<int>s[2]，一个栈先存左子树的根节点，一个栈先存右子树的根节点。 两个数组vector<int>v[2]
     1. 0 2 4 6 层压入 s[0] v[0]、 1 3 5 7层使用 s[1] v[1]
     2. 从s[0]中取出，向s[1]中先压入左结点的再压入右结点（因为取出的时候是右边的先出来）。将s[0]的取出压入v[0]中
     3. 如果v[0]非空，就把v[0]中的压入到res中
     4. 从s[1]中取出，向s[0]中先压入右结点再压入左节点（取出的时候先取出左边的）。将s[1]的取出压入v[1]中
     5. 如果v[1]中非空，就把v[1]的压入到res中
 
#### 2. [把二叉树打印成多行（二叉树的层次遍历）](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp)
- （层次遍历 BFS） 辅助： 队列 
- 题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。返回vector<vector<int> >
- 思路：使用两个队列。树的层次遍历，使用队列。
    - 使用两个队列，和两个数组。第一个队列出来后，下一层的数据按照从左到右的顺序放入第二个队列，先进先出，出来的顺序也是从左到右。
    - 只要两个队列有一个不为空就进入循环
    - 新建两个数组12（存放从栈中取出来的值）
    - 如果队列1不为空，取出队列头的值放到数组1中，把左右根节点放到栈2里，再弹出栈1的队列头元素。
    - 把数组1 中的值放到二维矩阵里面。
    - 队列二同理。
- 思路2：每次记录下来当前队列中的树节点个数，将这些树木的节点存入tmpvector中。并顺便压入每个节点的左节点和右节点。
 
#### 3. [从上往下打印二叉树](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
- （层次遍历 BFS）
- 题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 （不分行）
- 思路：不需要使用两个队列来存储当前层的节点和下一层的节点，因为在开始遍历第一层的节点时，当记录下来当前队列中的元素个数，前队列中的节点数就是当前层的节点数，就能保住这次遍历的都是当前层的节点。 
    - 使用一个队列和一个数组。
- 与上题的区别是，上题要求打印出多行，此题返回一行  vector<int> 

### 二叉树判断

#### 4. [对称的二叉树](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
- 题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
- 思路：调用递归函数，输入是两个树的根节点，返回这两棵树是否是对称的
    - 1. 如果都为空是对称的，2. 如果一个空，一个不空false 3. 如果根节点不等返回false 4. 递归，输入
    - 通常有三种不同的二叉树遍历算法，即前序遍历，中序遍历和后序遍历，在这三种遍历算法中，都是先遍历左节点再遍历右节点，一前序遍历为例，我们可以定义一个遍历算法，先遍历右子节点再遍历左子节点，暂且称其为前序遍历的对称遍历。通过比较二叉树的前序遍历序列（根左右），和对称前序遍历序列（根右左），将遍历时遇到的nullptr指针也考虑进来。
- 注意：要考虑，一个子树为空，一个子树不为空，返回false的情况。

#### 5. [平衡二叉树](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)
- 题目:输入一棵二叉树，判断该二叉树是否是平衡二叉树。平衡二叉树的定义是左右子树的高度差不超过1。
- 思路：定义递归函数，判断当前二叉树是否平衡，顺便求树的深度。思路是计算左右子树的深度，如果高度差大于1说明不平衡。
- 相关题目：计算二叉树的深度


#### 6. [树的子结构](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp)
- 题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
- 思路：
    - 1. 在树A中找与树B 根节点值相同的节点。找到相同节点后，调用函数判断两个相同根节点的树，树2是不是树1的子结构。
    - 2. 输入两棵树的根节点（根节点相同）在两棵树根节点相同的情况下，判断两棵树是否相等。循环截止条件：根节点的值不相等。
- 注意：空树不是任何树的子树


#### 7. [二叉树的后序遍历序列](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.cpp)
- 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
- 思路：后序遍历序列的最后一个元素是根节点 ，二叉搜索树的左子树所有节点都比根节点小，右子树都比根节点大
    1. 从后序遍历的第一个元素开始，找到比最后一个元素大的第一个元素，下标为i,这个元素左边[0,i-1]的应该是左子树
    2. 从第i个元素一直到第n-1个元素是右子树，所有节点的值应该小于根节点的值，如果比根节点的值大，返回false;
    3. 递归左子树 (.begin(),.begin()+i)
    4. 递归右子树 (.begin()+i , .end()-1)
-  注意：数组的.end() 指的是最后一个元素后面一个位置 

###  二叉树结点相关 

#### 8. [二叉搜索树的第k个结点](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)
- 题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 
- 思路：使用中序遍历的递归形式。注意：二叉搜索树的中序遍历是升序的。时间：O(K) 空间：O(1)
    - k作为变量，使用引用传递放在递归函数的形参中，每一次递归, 如果当前节点不是第k个，那么k--;知道k==1返回当前根节点。
- 注意：将k进行引用传递是为了记录访问的节点个数，也可以使用全局变量index记录访问的节点个数，就不用另外写一个递归函数了。


#### 9. [二叉树的中序遍历下一个结点]
- 题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
- 思路：1.当前节点为空（右）
    - 2. 当前节点有右节点，下一个节点是当前节点的右子树的最左节点（根）
    - 3. 否则，向上找第一个左节点指向的树包含该节点的祖先节点（左）

- 数据流中位数
- 如何得到一个数据流中的中位数


 ### 根据输入重建二叉树 （输入数组，输出二叉树 ）    
 
 #### 10. [重建二叉树]
- 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
- 思路：递归函数的输入是前序遍历和中序遍历的两个数组，以及两个数组中的范围，返回树的根节点。
    - 1. 前序遍历的第一个节点是根节点，在中序遍历中寻找到这个节点，利用这个值将中序遍历结果分为两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历结果。
    - 2. 求出中序遍历左半边的长度m,在前序遍历后面截取长度m,递归得调用得到左半边根节点和右半边根节点
    
### 二叉树变换（输入二叉树，输出二叉树/序列 ）    

#### 11.  [二叉树的镜像](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp)
- 题目：操作给定的二叉树，将其变换为原二叉树的镜像。
- 思路：递归 1.交换左右子树 2. 分别将左右子树做镜像（一二两步顺序可以调换）
- 注意，第4题对称的二叉树是判断一个二叉树是否是对称二叉树，此题是将二叉树变换为原二叉树的镜像
- [力扣101,判断二叉树是否为对称二叉树。](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)

#### 12. [二叉搜索树与双向链表]
- 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### 13. [序列化二叉树]
- 题目：实现两个函数，分别用来序列化和反序列化二叉树
- 思路：使用前序遍历来序列化和反序列化。只要自己写的格式对应的上即可，可以使用$符号来表示NULL,同时每个节点之间，需要添加逗号，即','进行分隔

### 二叉树信息

#### 14 [二叉树的深度](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp)
- 题目：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
- 思路：递归的思路，求左子树的深度和右子树的深度，当前深度为max(left,right)

#### 15. [二叉树中和为某一值的路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)
- 题目：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
- 思路：回溯法。 深度优先遍历，根节点，左子节点，右子节点（只能是先序遍历）
    - 方法一：二叉树中是否有满足目标和的路径，有的话就压入cur,压入res 
    - 递归终止条件
        1.  当前节点为叶节点，如果和为路径和为目标和，存储,在数组中删除当前节点，返回 
        2.  当前节点为叶节点，和不为目标和，删除当前节点，返回 
        
- 相关题目： [257. 二叉树的所有路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.cpp) [113.二叉树中和为目标值的所有路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)

- 回溯法，矩阵中的路径，机器人的运动范围 

## 栈和队列

#### 1. [用两个栈实现队列]
#### 2. [包含min函数的栈](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp)
- 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
- 思路：实现的类中有两个栈：原本的栈，以及存放每个元素的位置对应的最小数字的栈。如果压入的数字比最小栈中的元素小，就压入最小栈中，否则压入原来的最小值。

### 3. [栈的压入、弹出序列](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp)
- 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
- 思路：模拟的栈的压入和弹出
    - 1.压入push栈中的元素，压入的同时与Pop栈中的元素对比 ，如果相同就pop,
    - 2.当将Push数组中的元素全部处理完后，对比剩下栈中的元素与pop数组中的元素并弹出
    - 3.当栈中元素全部弹出后，k应该等于popV.size() 
- 用k指向是pop数组中下一个应该弹出的数字 的下标，当所有数字都被弹出的时候，k应该等于popV.size()

## 位运算

#### 1. [二进制中1的个数]

#### 2. [判断二进制中0的个数]

#### 3. [二进制高位连续0的个数]

## 数据流

#### - [数据流中的中位数]
#### - [字符流中只出现一次的字符]
  
## 递归和循环
#### 1. [斐波那契数列]

#### 2. [跳台阶]

#### 3. [变态跳台阶]

#### 4. [矩形覆盖]

## 回溯法

#### 1. [矩阵中的路径](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)


#### 2. [机器人的运动范围]


## 其他 

#### 1. [整数中1出现的次数](从1到n中的整数中1出现的次数)

#### 2. 扑克牌顺子

#### 3. 孩子们的游戏（圆圈中剩下的数）

#### 4. 替换空格 
  
#### 5. 数值的整数次方

#### 6. 顺时针打印矩阵

#### 7. 最小的k个数(堆排序)
- 堆排序/快排


#### 8. 丑数
 


## c++

1. int 转 string 
```
to_string(x)
```
2. sort函数重写比较函数（从大到小排列）
```
static bool cmp(int x, int y){
return x>y?true:false;
}
```

3. 哈希表

```
unordered_map(int,int)res;//哈希表 
//查看哈希表中某个数字的数目：
res.count(20);
```
4. 是奇数/偶数
```
x%2 == 0 -> 是偶数 / x%2 == 1 -> 是奇数 
```
5. 复制一个数组 （把dq中的复制到array中)
```
array.assign(dq.begin(),dq.end());
```
6. 初始化数组为0 
```
int count[256] = {0};
```
7. 取字符串的子串
```
str.substr(n,len);//从下标为n的数开始，取len长度的字符串 
```
8.  c语言，矩阵
```
bool * visited = new bool[rows* cols]

memset(visited,0,rows* cols)

第[row][col]元素：表示为 visited[row* cols+col ]

delete []visited ;
```
9. 链表和树的结构体 
10. deque 是双端队列 queue是单端队列 
```
queue 基本操作

push(x) 将x压入队列的末端

pop() 弹出队列的第一个元素(队顶元素)，注意此函数并不返回任何值

front() 返回第一个元素(队顶元素)

back() 返回最后被压入的元素(队尾元素)

empty() 当队列为空时，返回true

size() 返回队列的长度

```
11. 绝对值函数 abs（left-right）;
12. 用vector建堆
```
vector make_heap(res.begin(), res.end(),greater<int>()//建堆 最小堆 如果是最大堆就是 less<int>() 

//压入
res.push_back(res.begin(), res.end())//将新元素放在堆最后
push_heap()//(压入之后排序）调整堆
//弹出
pop_heap(res.begin(), res.end()) //弹出之前排序 //将最小元素放在堆最后 
res.pop_back() //删除堆中最后的元素（最小的元素）
```
13. 空的类所占内存是1 
    - 空类的实例不包含任何信息，但是我们在声明该类型的实例的时候，必须在内存中占有一定的空间，否则就无法使用。在vs中占一个字节。
    - 如果加了构造函数和析构函数，所占空间还是1。
    - 如果析构函数设为了虚函数，如果c++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，如果是在32位的机器上，一个指针占4字节的空间，sizeof(指针) =  4 。如果是64位的机器，一个指针占8字节的空间。
    
