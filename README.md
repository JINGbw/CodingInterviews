

Table of Contents
=================

   * [NowCoder](#nowcoder)
      * [排序问题](#排序问题)
         * [快速排序](#快速排序)
         * [归并排序](#归并排序)
         * [堆排序](#堆排序)
      * [数组](#数组)
         * [数组查找](#数组查找)
            * [1. 二维数组的查找](#1-二维数组的查找)
            * [3. 数组中重复的数字](#3-数组中重复的数字)
            * [4. 连续子数组的最大和](#4-连续子数组的最大和)
            * [5. 旋转数组的最小数字](#5-旋转数组的最小数字)
            * [6. 数组中出现次数超出一半的数字](#6-数组中出现次数超出一半的数字)
            * [7. 数组中的逆序对](#7-数组中的逆序对)
            * [和为s的数字](#和为s的数字)
            * [和为s的连续整数序列](#和为s的连续整数序列)
            * [滑动窗口的最大值](#滑动窗口的最大值)
            * [队列的最大值](#队列的最大值)
         * [数组排序](#数组排序)
            * [8. 把数组排成最小的数](#8-把数组排成最小的数)
            * [9. 调整数组顺序使奇数位于偶数前面](#9-调整数组顺序使奇数位于偶数前面)
         * [数组其他](#数组其他)
            * [10. 构建乘积数组](#10-构建乘积数组)
            * [11. 顺时针打印矩阵](#11-顺时针打印矩阵)
            * [12. 矩阵中的路径](#12-矩阵中的路径)
      * [字符串](#字符串)
         * [字符串常规](#字符串常规)
            * [1. 替换空格](#1-替换空格)
            * [2. 正则表达式匹配](#2-正则表达式匹配)
            * [3. 表示数值的字符串](#3-表示数值的字符串)
            * [4. 第一个只出现一次的字符位置（字符串中第一个不重复的字符）](#4-第一个只出现一次的字符位置字符串中第一个不重复的字符)
            * [5. 字符流中第一个不重复的字符](#5-字符流中第一个不重复的字符)
            * [6. 字符串的排列（全排列）](#6-字符串的排列全排列)
            * [7. 翻转字符串](#7-翻转字符串)
            * [8. 左旋转字符串](#8-左旋转字符串)
            * [9. 最长不含重复字符的子字符串](#9-最长不含重复字符的子字符串)
      * [链表](#链表)
         * [链表结点](#链表结点)
            * [1. 链表中倒数第k个结点](#1-链表中倒数第k个结点)
            * [2. 链表中环的入口节点](#2-链表中环的入口节点)
            * [3. 两个链表的第一个公共结点](#3-两个链表的第一个公共结点)
            * [4. 删除链表中重复的结点](#4-删除链表中重复的结点)
         * [链表打印/转换](#链表打印转换)
            * [5. 从尾到头打印链表](#5-从尾到头打印链表)
            * [6. 反转链表](#6-反转链表)
            * [7. 二叉搜索树与双向链表](#7-二叉搜索树与双向链表)
            * [8. 合并两个排序的链表](#8-合并两个排序的链表)
            * [9. 链表回文结构](#9-链表回文结构)
            * [10. 把字符串转换成整数(Atoi)](#10-把字符串转换成整数atoi)
            * [11. 复杂链表的复制](#11-复杂链表的复制)
      * [树](#树)
      * [Trie树](#trie树)
      * [哈夫曼树](#哈夫曼树)
      * [二叉树](#二叉树)
         * [二叉树遍历，打印](#二叉树遍历打印)
            * [1. 按之字形顺序打印二叉树](#1-按之字形顺序打印二叉树)
            * [2. 把二叉树打印成多行（二叉树的层次遍历）](#2-把二叉树打印成多行二叉树的层次遍历)
            * [3. 从上往下打印二叉树](#3-从上往下打印二叉树)
         * [二叉树判断](#二叉树判断)
            * [4. 对称的二叉树](#4-对称的二叉树)
            * [5. 平衡二叉树](#5-平衡二叉树)
            * [6. 树的子结构](#6-树的子结构)
            * [7. 二叉树的后序遍历序列](#7-二叉树的后序遍历序列)
         * [二叉树结点相关](#二叉树结点相关)
            * [8. 二叉搜索树的第k个结点](#8-二叉搜索树的第k个结点)
            * [9. 二叉树的中序遍历下一个结点](#9-二叉树的中序遍历下一个结点)
         * [根据输入重建二叉树 （输入数组，输出二叉树 ）](#根据输入重建二叉树-输入数组输出二叉树-)
            * [10. 重建二叉树](#10-重建二叉树)
         * [二叉树变换（输入二叉树，输出二叉树/序列 ）](#二叉树变换输入二叉树输出二叉树序列-)
            * [11.  二叉树的镜像](#11--二叉树的镜像)
            * [12. 二叉搜索树与双向链表](#12-二叉搜索树与双向链表)
            * [13. 序列化二叉树](#13-序列化二叉树)
         * [二叉树信息](#二叉树信息)
            * [14 二叉树的深度](#14-二叉树的深度)
            * [15. 二叉树中和为某一值的路径](#15-二叉树中和为某一值的路径)
      * [栈和队列](#栈和队列)
         * [1. [用两个栈实现队列]](#1-用两个栈实现队列)
         * [1.5 [两个队列实现栈] （见leetcodeleetcode总结）](#15-两个队列实现栈-见leetcodeleetcode总结)
         * [2. 包含min函数的栈](#2-包含min函数的栈)
         * [3. 栈的压入、弹出序列](#3-栈的压入弹出序列)
      * [位运算](#位运算)
      * [逻辑运算](#逻辑运算)
         * [数组中只出现一次数字](#数组中只出现一次数字)
         * [数组中只出现一次数字-变种1](#数组中只出现一次数字-变种1)
         * [数组中只出现一次数字-变种2](#数组中只出现一次数字-变种2)
         * [数组中只出现一次数字-变种3](#数组中只出现一次数字-变种3)
         * [1. 二进制中1的个数](#1-二进制中1的个数)
         * [2. 判断二进制中0的个数](#2-判断二进制中0的个数)
         * [3. 二进制高位连续0的个数](#3-二进制高位连续0的个数)
      * [数据流](#数据流)
         * [[数据流中的中位数]](#数据流中的中位数)
         * [字符流中只出现一次的字符](#字符流中只出现一次的字符)
      * [动态规划dp](#动态规划dp)
         * [把数字翻译成字符串](#把数字翻译成字符串)
         * [相似题：把字符串转换成整数（Atoi）](#相似题把字符串转换成整数atoi)
         * [股票的最大利润(dp) 一次买卖](#股票的最大利润dp-一次买卖)
         * [连续数组的最大和(dp)](#连续数组的最大和dp)
      * [递归和循环](#递归和循环)
         * [1. 斐波那契数列](#1-斐波那契数列)
         * [2. 跳台阶](#2-跳台阶)
         * [3. 变态跳台阶](#3-变态跳台阶)
         * [4. 矩形覆盖](#4-矩形覆盖)
      * [DFS](#dfs)
         * [2. 机器人的运动范围 深度优先遍历](#2-机器人的运动范围-深度优先遍历)
         * [DFS 回溯法](#dfs回溯法)
            * [矩阵中的路径](#矩阵中的路径)
         * [字符串的排列，全排列](#字符串的排列全排列)
         * [二叉树中和为某一值的路径](#二叉树中和为某一值的路径)
         * [八皇后](#八皇后)
      * [其他](#其他)
         * [1. <a href="从1到n中的整数中1出现的次数">整数中1出现的次数</a>](#1-整数中1出现的次数)
         * [2. 扑克牌顺子](#2-扑克牌顺子)
         * [3. 孩子们的游戏（圆圈中剩下的数）](#3-孩子们的游戏圆圈中剩下的数)
         * [4. 替换空格](#4-替换空格)
         * [5. 数值的整数次方](#5-数值的整数次方)
         * [6. 顺时针打印矩阵](#6-顺时针打印矩阵)
         * [7. 最小的k个数(堆排序)](#7-最小的k个数堆排序)
         * [8. 丑数](#8-丑数)
      * [图搜索](#图搜索)
         * [最少操作次数](#最少操作次数)
         * [最少操作次数的简易版](#最少操作次数的简易版)
         * [单词游戏（矩阵中的路径）](#单词游戏矩阵中的路径)
         * [八皇后问题](#八皇后问题)
         * [八数码问题 （我的 跟谁学 面试题）](#八数码问题-我的-跟谁学-面试题)
      * [c  ](#c)
      * [暂时记在这里 with <g-emoji class="g-emoji" alias="moon" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f314.png">🌔</g-emoji>](#暂时记在这里-with-moon)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)



****
# NowCoder
剑指Offer 66题刷题笔记
 
## 排序问题

### 快速排序

### 归并排序

### 堆排序

用**数组**和链表实现堆


以**最大堆（用数组实现的）**为例：数组的第一个元素是最大的。

**堆的插入：**

1. 在数组最后放入要插入的元素
2. 相当于一个上浮操作，最坏情况下，要移动完全二叉树的深度次。（完全二叉树的深度是$O(log_2^(n))$）

:warning: :warning: 由于堆是一棵完全二叉树，存在n个元素，那么他的高度为:$log_2^(n+1)$，这就说明代码中的for循环会执行$O(log_2^(n))$次。因此插入函数的时间复杂度为：$O(log_2^(n))$。

**堆的删除**

最大堆的删除总是从堆的根节点删除，可以看做是**最大堆最后一个结点的下沉**。对于最大堆的删除，我们不能自己进行选择删除某一个结点，我们只能删除堆的根结点。:warning: 

 

时间复杂度：$O(log_2^(n))$。

 

**堆排序**

- [讲解堆排序的网站](https://www.jianshu.com/p/21bef3fc3030)




## 数组

### 数组查找 

#### 1. 二维数组的查找

- 题目：二维数组从左到右依次变大，从上到下依次变大，找到目标数字
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE.cpp)：法一：利用二分法找到该数所在的行，再用二分法找到这个数。法二：从左下角或者右上角开始找，可以根据Target与当前元素的大小关系来缩小查找区间


#### 3. 数组中重复的数字
- 题目：找出数组中重复的数字，数组长度为n,所有数字的范围都在0~n-1的范围内，有一些重复的数字，不知道哪个数字重复了几次，也不知道几个数字重复了，**随便**找到一个。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.cpp)：如果第i个数不等于i,就把第i个数换到i的位置去，如果第i个数那个数的位置 等于那个数，就说明找到了重复的数字
- 思路1：哈希表。时间O(1),空间O(N)
- 思路2：遍历数组。比较数字和下标。如果数字和下标相等，就看下一个。如果第i个数不等于i,就把第i个数换到i的位置去，如果第i个数那个数的位置等于那个数，就说明找到了重复的数字。时间O(N),空间O(1)
 
### 数组中重复的数字 变种 - 统计次数
- 题目：不修改数字找出重复的数字
- 思路1：哈希表O(N)
- 思路2：按照中间的数字把数组分为两半，比如有8个数，范围在1~7中，那就用4，统计1~4出现的次数，如果出现次数超过了4，那么重复数字一定在1~4中，再用二分法进行统计。

- 类似问题  字符串中第一个不重复的字符 

#### 数字在排序数组中出现的次数
- 题目：统计一个数字在排序数组中出现的次数
- 思路：由于是排序的，考虑用二分法，在数组中找到第一个这个数字，再找到最后一个这个数字，二者下标相减。

#### 0~n-1中缺失的数字 - 用二分
- 题目：长度为n-1的**递增排序**数组中所有的数字都是唯一的，并且每个数字的范围都在0~n-1内，n个数字有且只有一个数字不在这个数组中，找出这个数字
- 思路：由于是排序的，那么开始的数字，下标与这个数字下标相同。 使用二分，如果中间数字和下标相等，就去右边找。否则去左边。直到发现m正好是数组中第一个数值和下标不相等的数字。返回m

#### 数组中数值和下标相等的元素
- 题目：单调递增数组中每个元素都是整数且唯一。求找出任意一个与其下标相等的元素
- 思路：如果当前值比下标大，就向左边找，否则向右边找，直到等于。


#### 4. 连续子数组的最大和
:sob: :sob:
**饿了么面试考 ：(**  还要求出子数组到底是什么
- 题目：找到给定数组中连续子数组的最大和。输入一个整形数组，数组中有正数也有负数，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值，要求时间复杂度为O(N)
- 思路0
    - 使用两个数字记录
- [思路1](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)：动态规划的状态转移方程：dp[i]数组存放着以第i个数字结尾的，连续子数组的最大和
    - dp[i] = array[0] , (i = 0) 
    - dp[i] = max(dp[i-1] + array[i],array[i]); (i = 1,2 ,3 ... n-1) 

**得到动态规划的数组之后，遍历一遍数组，最大值的下标即为最大和，这么简单还没写出来，我好后悔..不想面对..**

**注** :warning:
- （力扣）上有一题是求最长上升子序列的长度，不要搞混了  
- 这题于股票的最大利润（只能买卖一次有些像，但是股票买卖利润的使用了两个dp数组，分别存放的是，第i个值之前的最小值，和当前天之前买卖的最大利润。输出profit数组中最后一个元素即可。）而本题最后要再遍历一遍矩阵。


#### 5. 旋转数组的最小数字
- 相关：[在旋转数组中寻找目标数字]

#### 6. 数组中出现次数超出一半的数字
- 相关：[数组中出现次数等于一半的数字]
- 题目： 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。**如果不存在则输出0。**
- 思路：使用两个数字，用一个数记录数组中的一个数字，一个是次数(只适用于总数是奇数的情况)
    - 如果下一个数字与保存的数字是一样的，则次数加1，如果不同，就次数减一，如果次数为0，
    - 就保存下一个数字，把次数设为1，因为我们要找的数字出现的次数比其它全部数字的出现次数之和还要大，则要找的数字肯定是组后一次把次数设为1时相应的数字。该方法的时间复杂度为O(n)，空间复杂度为O(1)。
- 注意： 由于不存在要输出0，所以最后还要遍历一遍数组，统计该数字出现的次数。
- 总结：如果可以修改数组，可以使用partition(快排)的方法，如果不可以修改数组，就使用这种方法
- 变种题：寻找出现次数等于n/2的数字 (并且数字的个数是n) 
    - 上一种解法在数字个数为偶数的时候就失效了。
    - 修改方法为：在数组中随便找一个数字，再把这个数字删除，再对剩下的数字做刚刚的操作。对比这个数字，和最后得到的数字，再遍历两遍原数组（一共遍历了三次数组复杂度为3n）

#### 7. 数组中的逆序对
**lc小米面试考**
- 题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
- 思路：归并排序，二分。在归并排序的合并阶段统计逆序对的个数。
    - 现在有两个已经排好序（从小到大）的数组A和数组B ，使用两个指针从两个数组的最后一个元素指。i为数组A中最后一个元素的下标，j为数组B中最后一个元素的下标。
    - 如果A[i]>A[j],说明A[i]大于从A[mid+1]（A中的第一个元素）到A[j]的每一个元素，逆序对count+= (j-(mid+1))+1也就是  count+= j-mid ;

#### 和为s的数字
- 对比力扣2sum是找到数组中 和为给定值的两个数的下标
- 题目：输入递增排序的数组，和一个数字s。在递增排序的数组中，查找两个数，使得他们的和正好是s，如果有多对数字的和等于s，则输出任意一对即可。
- 思路：使用两个指针，一个指向数组的第一个元素，一个指向数组的最后一个元素，如果和大于target ,small++; 否则 big--;等于target则返回。
- 为什么不使用两个指针都从数组的头或者尾开始指？这样两个指针走的方向是一样的。都是向前或者向后。

#### 和为s的连续整数序列 
- 题目:输入一个数字s，输出和为s的连续正数序列
- 思路：使用两个数，small和big 分别表示序列的最小值和最大值，small初始化为1，big 初始化为 2。如果从big加到small的值大于和s。则从序列中去掉较小的值，如果小于就增大big。直到small等于 (1+s)/2 为止。
- **注**:warning:：这个题与 **和为s的数字** 一样，都是使用两个指针 计算和，和大small++，和小就big--;

#### 滑动窗口的最大值
- 题目：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。

#### 队列的最大值
- 题目：请定义一个队列并实现函数max得到队列里的最大值，要求函数max,push_back, pop_front和pop_front的时间复杂度都是o(1)。

### 数组排序

#### 8. 把数组排成最小的数

- 题目：把数组（int类型）里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个
- [思路1](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp)：
    - 1. 对数组中所有元素进行排序，并重新定义排序函数中调用的比较函数cmp，  
    - 2. 将排好序的数组拼接起来返回
 - 注：lambda函数 如果返回时True,就从大到小排序 否则从小到大排序。
 - 
``` 
 if (to_string(x)+to_string(y)<to_string(y)+to_string(x))
            return true; 
``` 
 - 思路2：把问题转化为全排列的问题。时间复杂度是O(N!)
 
   
#### 9. 调整数组顺序使奇数位于偶数前面

- 题目：调整数组中数字的顺序，使奇数在偶数前面
- 思路0: 最原始的解法：从头扫描这个数组，每碰到一个偶数，把这个偶数拿出来，就把后面的往前挪动一个。挪动之后有了空位就把偶数放到空位。时间复杂度是O(n^2)
- 思路1：使用两个指针，一个从前面走到偶数停止，一个从后面走，走到奇数停止，交换奇数偶数（交换的时候算做时间复杂度）。时间O(N),空间O(1)缺点是，奇数偶数的相对位置改变了。(这个是一个可扩展性的方法，因为可以把判断是不是奇数封装成一个函数)
- [思路2](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp)：1.奇数放在前半部分，从原来数组的后面开始找 ,从前面插入到双端队列 2.偶数放在后半部分，从前开始找，插入双端队列的后面 时间O(1) 空间O(N) 用空间换时间 




####

### 数组其他
#### 10. 构建乘积数组

- 题目：给定数组A[0,1,...n-1]，要求构建B[0,1,...n-1],其中B的元素B[i] = A[0]A[1]...A[i-1]A[i+1]...A[n-1]。要求不能使用除法
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.cpp)：循环B数组两遍，将B中结果拆成两部分乘积，一部分是下三角形，一部分是上三角形。
    -  B[0] = 1 ,i从1到n-1 ,$B[i]=B[i-1]* A[i-1]$ 
    -  i从n-2到0 ，$ tmp*= A[i+1], B[i] = B[i]* tmp$
 


#### 11. 顺时针打印矩阵

- 题目：按照顺时针的顺序打印出矩阵中的每一个数字 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp)：
    1. 从左到右
    2. 从上到下 判断跳出条件 top==bottom
    3. 从右到左 right == left
    4. 从下到上 top = bottom-1 
- 注意循环截止条件 （3.4.的时候考虑）(只有一行或者一列的情况)

#### 12. 矩阵中的路径
- 题目：矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)：使用一个bool矩阵记录矩阵的当前位置是否走过，使用一个变量pathlength记录走到了字符串的哪个位置 。
    -  对于数组中的每一个位置，都调用递归函数，从数组第row,col这个位置开始找，是否有字符串第pathlenhgth(包含这个位置，及以后的子串)
    -  如果当前位置没有超出范围，且当前位置没走过，且当前位置等于字符串pathlength元素，进入函数 
- **注** :warning:：如果形参未引用，那么实参不能在传参时进行加减。需要先计算好再传入


## 字符串
### 字符串常规
#### 1. 替换空格
- 题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.cpp)：1. 遍历字符串，统计字符串的空格个数和非空格个数，得到替换后的长度      2. 从后往前替换，如果是空格就换为“%20”

#### 2. 正则表达式匹配

#### 3. 表示数值的字符串

#### 4. 第一个只出现一次的字符位置（字符串中第一个不重复的字符）
- 题目：找到字符串中一个只出现一次的字符位置
- 思路：使用哈希表 （或者长度为256的数组做哈希表） 1. 遍历一遍，使用哈希表记录每个字符出现的次数 2. 再遍历一遍，如果只出现一次，返回

#### 5. 字符流中第一个不重复的字符
- 题目：找到字符流中第一个不重复的字符（两个函数 ，一个用于向字符流中插入字符，一个用于找到第一个不重复的字符）
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.cpp)：1. 使用string s 记录该字符流 2. 使用哈希表（长度为256），初始化为-1，如果出现一次，occur[i]记录为它再字符流中的位置，没有出现过是-1 ，出现超过一次，出现过多次记录为-2。

（还有字符串中第一个不重复的字符 用哈希表来做（长度为256的数组，记录每个字符出现的次数））O(n)


#### 6. 字符串的排列（全排列）
- 题目：输入字符串求全排列
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%89.cpp)：递归让每个数字当第一个，循环截止条件：递归到了最后一个数字/每次递归结束后再换回来。
    - 递归函数：```void core(string str,   vector<string>  &res , int  num )```
    - 递归的条件：1. 当前数字是第一个或者当前值与第一个值不等才会交换和递归
    - 传进去的数字是记录对字符串从第（num）个数，到最后一个数进行全排列。    

:warning:  1. 空字符串判断 2. 输出之前排序 3. 重复的情况判断

#### 7. 翻转字符串

- 题目：将英文句子中的单词顺序翻转，但是单词内字符的顺序不变
- 思路：1. 在原字符串后加空格，作为标记，以空格为标记，翻转每个子单词 2. 删除单词，翻转整个字符串 

#### 8. 左旋转字符串

- 题目：左旋转字符串ROL ，将string str左移n位 
- 思路1 ：相当于在原来的字符串后面再加上一个原来的字符串，取新字符串的 .substr(n, len);//n= n%len 
- 思路2 ：利用上面翻转字符串的思路，先翻转前面n个，再翻转整个字符串。

#### 9. 最长不含重复字符的子字符串

## 链表

### 链表结点

#### 1. 链表中倒数第k个结点
- 题目：输入一个链表，输出该链表中倒数第k个结点。
- 思路：一个指针先向前走k-1步，两个指针再一起向前走，前面的指向空了，就找到了倒数第k个结点。

#### 2. 链表中环的入口节点
- 题目：找到链表中环的入口节点
- 思路：
    - 法一：1. 使用两个指针，一个比另一个速度快一步，两个一起向前走，如果相遇，相遇点一定在环中。2. 使用两个指针，一个从相遇处开始走，一个从头节点开始走，如果再次相遇，相遇点就是环的入口
    - 法二：1.同上 2. 在第一步相遇后，使用一个节点记录相遇处，另一个节点在环中绕一圈，就可以得到环的长度。3. 得到环的长度后，使用两个指针，一个先走环的长度，两个指针再一起走。
    
#### 3. 两个链表的第一个公共结点
- 题目：输入两个链表，找出它们的第一个公共结点。
- 思路：因为都是单链表，两个链表一旦相交就不会分开了。
    - 法一：1. 先分别遍历两个链表，得到两个链表的长度 2. 比较长的链表先走（两个链表长度的差值）再一起向前走，直到相遇
    - 法二：1. 使用两个指针，一个从链表A开始走，如果走到了尾部，就从B的头部重新开始访问B 。另一个从链表B开始走，如果走到尾部就从链表A的头部重新开始访问。当两个指针相遇的时候，就是两个链表的第一个公共结点。 
    
#### 4. 删除链表中重复的结点
- 题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp)：使用三个指针，pre,cur,next ,pre指向不重复的最后一个，cur指向重复的第一个，next指向重复的最后一个
     - 如果cur和它下一个一样，就用next向后找，走到最后一个重复的节点。
     - 如果cur是第一个节点，就删除cur到next,将指向第一个元素的指针指向pHead  
         
    
### 链表打印/转换 

#### 5. 从尾到头打印链表
- 题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
- 思路：法一：使用栈或者递归 
    - 法二：使用头插法构建逆序链表
    
#### 6. 反转链表
- 题目：原地翻转链表 输出新链表的表头 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp)：使用四个指针 pre,cur,next,newhead 

- 反转链表的一部分
- 题目：反转链表中的部分节点，使用一趟扫描完成反转（第m个到第n个）
- [思路](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E9%93%BE%E8%A1%A8/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II.cpp)：使用三个指针pre,cur,nt 反转链表 。时间复杂度：O(N)。空间复杂度：O(1)
    -  一个指针向前走m-1步走到第一个待翻转的结点。pre指向待反转的前一个结点
    -  cur指向待反转的第一个节点 ， 一次翻转 cur 和 next 两个 ，一直到n
    -  修改每个指针的->next 先修改cur,再next，最后Pre 
    

#### 7. 二叉搜索树与双向链表
- 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.cpp)：二叉搜索树的中序遍历是从大到小排列的，由于转换要求是排好序的，所以使用中序遍历
    - 当前节点为空则返回
    - 当前节点是否有左节点，有的话就递归
    - 当前节点左指向递归结果
    - 当前递归结果如果不为空，递归结果指向当前节点
    - 当前节点是否有右节点，有的话就递归
- 这里注意一级指针和二级指针的转换 




#### 8. 合并两个排序的链表
- 题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
- 思路：1. 如果一个为空就直接返回另一个 2. 利用递归的方法，两个链表头节点中比较小的，下一个结点接上递归调用剩下的。

#### 9. 链表回文结构
 

#### 11. 复杂链表的复制
- 题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。next指针，random指针，val 
- 思路：1. 在原来链表每个节点后面插入复制的节点，复制next和val 2. 复制random 3. 将一个链表拆成两个 
- 注意：如何将一个链表拆成两个，（先用一个指针指向拆开后的头结点）。
     - p1是原来链表的指针，先让p1向前走一步，循环终止条件是p1不为空。
## 树

1. 完全二叉树：堆就是由完全二叉树组成的，前n-1层全满，第n层只有右边可以是空的。
2. 满二叉树： 树中每个分支结点都有2棵非空子树。
3. 二叉搜索树： 二叉搜索树的所有左子节点的值都小于右子节点的值。
4. AVL树：AVL树是最早被发明的自平衡二叉查找树。 在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。 查找、插入和删除在平均和最坏情况下的時間複雜度都是 。 增加和删除元素的操作则可能需要藉由一次或多次树旋转，以实现树的重新平衡。
## Trie树
- Trie树 ，字典树，又称单词查找树，是一种树形结构，常用于统计和排序大量字符串等场景中，经常被搜索引擎用于文本词频统计，它的有点事最大限度地减少无畏的字符串比较，查询效率比较高。三个基本性质
    - 根节点不包含字符，除根节点外，每个节点只包含一个字符
    - 从根节点到某一节点的路径上经过的字符连接起来，即为该节点对应的字符串。如果某个节点被标记为红色，表示这个单词存在，否则不存在，对于一个单词，只要顺着它的根节点走到对应的节点，再看看这个结点是否被标记为红色就知道这个
    - 每个节点的所有子节点包含的字符都不同
- 数据结构：Trie 树可以用动态链表和数组来模拟动态，空间的花费不会超过单词数乘以单词的长度。也可以用堆来实现。
- 时间复杂度：n个单词，平均长度为len
    - 统计：使用Trie树来统计每个词出现的次数，时间复杂度是O(N * len)
    - 查找：找出其中出现最频繁的10个词：时间复杂度：O(Nlog10)
- [Trie树的应用](https://www.cnblogs.com/lisen10/p/10922670.html)：
    - 字符串检索 检索/查询功能是Trie树最原始的功能。给定一组字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较：如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。
    - 词频统计 为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数  对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。
    - 排序
    - 前缀匹配
    - 最长公共前缀
    - 作为辅助结构
- 应用实例
    - 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
    - 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
    - 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？
    - 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
    - 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。
- Trie树的实现
    - Trie树的插入、删除、查找的操作都是一样的，只需要简单的对树进行一遍遍历即可，时间复杂度：O(n)（n是字符串的长度）。
    - 数组： 由于我们知道一个Tried树节点的子节点的数量是固定26个（针对不同情况会不同，比如兼容数字，则是36等），所以可以使用固定长度的数组来保存节点的子节点
        - 优点：在对子节点进行查找时速度快
        - 缺点：浪费空间，不管子节点有多少个，总是需要分配26个空间
    - 链表：使用链表的话我们需要在每个子节点中保存其兄弟节点的链接，当我们在一个节点的子节点中查找是否存在一个字符时，需要先找到其子节点，然后顺着子节点的链表从左往右进行遍历
        - 优点：节省空间，有多少个子节点就占用多少空间，不会造成空间浪费
        - 缺点：对子节点进行查找相对较慢，需要进行链表遍历，同时实现也较数组麻烦
## 哈夫曼树
- 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

**基本术语**

哈夫曼树又称为最优树.

**1、路径和路径长度**

在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。

**2、结点的权及带权路径长度**

若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。

**3、树的带权路径长度**

树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL

**霍夫曼树有什么好处呢？**

一般得到霍夫曼树后我们会对叶子节点进行霍夫曼编码，由于权重高的叶子节点越靠近根节点，而权重低的叶子节点会远离根节点，这样我们的高权重节点编码值较短，而低权重值编码值较长。这保证的树的带权路径最短，也符合我们的信息论，即我们希望越常用的词拥有更短的编码。如何编码呢？一般对于一个霍夫曼树的节点（根节点除外），可以约定左子树编码为0，右子树编码为1。



## 二叉树 
### 二叉树遍历（非递归）
#### 前序

#### 中序

#### 后序


### 二叉树遍历，打印 

#### 1. 按之字形顺序打印二叉树
- （类似层次遍历）
- 题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：使用两个栈stack<int>s[2]，一个栈先存左子树的根节点，一个栈先存右子树的根节点。 两个数组vector<int>v[2]
     1. 0 2 4 6 层压入 s[0] v[0]、 1 3 5 7层使用 s[1] v[1]
     2. 从s[0]中取出，向s[1]中先压入左结点的再压入右结点（因为取出的时候是右边的先出来）。将s[0]的取出压入v[0]中
     3. 如果v[0]非空，就把v[0]中的压入到res中
     4. 从s[1]中取出，向s[0]中先压入右结点再压入左节点（取出的时候先取出左边的）。将s[1]的取出压入v[1]中
     5. 如果v[1]中非空，就把v[1]的压入到res中
 
#### 2. 把二叉树打印成多行（二叉树的层次遍历）
- （层次遍历 BFS） 辅助： 队列 
- 题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。返回vector<vector<int> >
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp)：使用两个队列。树的层次遍历，使用队列。
    - 使用两个队列，和两个数组。第一个队列出来后，下一层的数据按照从左到右的顺序放入第二个队列，先进先出，出来的顺序也是从左到右。
    - 只要两个队列有一个不为空就进入循环
    - 新建两个数组12（存放从栈中取出来的值）
    - 如果队列1不为空，取出队列头的值放到数组1中，把左右根节点放到栈2里，再弹出栈1的队列头元素。
    - 把数组1 中的值放到二维矩阵里面。
    - 队列二同理。
- 思路2：每次记录下来当前队列中的树节点个数，将这些树木的节点存入tmpvector中。并顺便压入每个节点的左节点和右节点。
 
#### 3. 从上往下打印二叉树
- （层次遍历 BFS）
- 题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 （不分行）
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：不需要使用两个队列来存储当前层的节点和下一层的节点，因为在开始遍历第一层的节点时，当记录下来当前队列中的元素个数，前队列中的节点数就是当前层的节点数，就能保住这次遍历的都是当前层的节点。 
    - 使用一个队列和一个数组。
- 与上题的区别是，上题要求打印出多行，此题返回一行  vector<int> 

### 二叉树判断

#### 4. 对称的二叉树

- 题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：调用递归函数，输入是两个树的根节点，返回这两棵树是否是对称的
    - 1. 如果都为空是对称的，2. 如果一个空，一个不空false 3. 如果根节点不等返回false 4. 递归，输入
    - 通常有三种不同的二叉树遍历算法，即前序遍历，中序遍历和后序遍历，在这三种遍历算法中，都是先遍历左节点再遍历右节点，一前序遍历为例，我们可以定义一个遍历算法，先遍历右子节点再遍历左子节点，暂且称其为前序遍历的对称遍历。通过比较二叉树的前序遍历序列（根左右），和对称前序遍历序列（根右左），将遍历时遇到的nullptr指针也考虑进来。
- 注意：要考虑，一个子树为空，一个子树不为空，返回false的情况。

#### 5. 平衡二叉树

- 题目:输入一棵二叉树，判断该二叉树是否是平衡二叉树。平衡二叉树的定义是左右子树的高度差不超过1。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：定义递归函数，判断当前二叉树是否平衡，顺便求树的深度。思路是计算左右子树的深度，如果高度差大于1说明不平衡。
- 相关题目：计算二叉树的深度


#### 6. 树的子结构
- 题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp)：
    - 1. 在树A中找与树B 根节点值相同的节点。找到相同节点后，调用函数判断两个相同根节点的树，树2是不是树1的子结构。
    - 2. 输入两棵树的根节点（根节点相同）在两棵树根节点相同的情况下，判断两棵树是否相等。循环截止条件：根节点的值不相等。
- 注意：空树不是任何树的子树


#### 7. 二叉树的后序遍历序列
- 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.cpp)：后序遍历序列的最后一个元素是根节点 ，二叉搜索树的左子树所有节点都比根节点小，右子树都比根节点大
    1. 从后序遍历的第一个元素开始，找到比最后一个元素大的第一个元素，下标为i,这个元素左边[0,i-1]的应该是左子树
    2. 从第i个元素一直到第n-1个元素是右子树，所有节点的值应该小于根节点的值，如果比根节点的值大，返回false;
    3. 递归左子树 (.begin(),.begin()+i)
    4. 递归右子树 (.begin()+i , .end()-1)
-  注意：数组的.end() 指的是最后一个元素后面一个位置 

###  二叉树结点相关 

#### 8. 二叉搜索树的第k个结点
- 题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)：使用中序遍历的递归形式。注意：二叉搜索树的中序遍历是升序的。时间：O(K) 空间：O(1)
    - k作为变量，使用引用传递放在递归函数的形参中，每一次递归, 如果当前节点不是第k个，那么k--;知道k==1返回当前根节点。
- 注意：将k进行引用传递是为了记录访问的节点个数，也可以使用全局变量index记录访问的节点个数，就不用另外写一个递归函数了。


#### 9. 二叉树的中序遍历下一个结点
- 题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
- 思路：1.当前节点为空（右）
    - 2. 当前节点有右节点，下一个节点是当前节点的右子树的最左节点（根）
    - 3. 否则，向上找第一个左节点指向的树包含该节点的祖先节点（左）

- 数据流中位数
- 如何得到一个数据流中的中位数


 ### 根据输入重建二叉树 （输入数组，输出二叉树 ）    
 
 #### 10. 重建二叉树
- 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
- 思路：递归函数的输入是前序遍历和中序遍历的两个数组，以及两个数组中的范围，返回树的根节点。
    - 1. 前序遍历的第一个节点是根节点，在中序遍历中寻找到这个节点，利用这个值将中序遍历结果分为两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历结果。
    - 2. 求出中序遍历左半边的长度m,在前序遍历后面截取长度m,递归得调用得到左半边根节点和右半边根节点
    
### 二叉树变换（输入二叉树，输出二叉树/序列 ）    

#### 11.  二叉树的镜像
- 题目：操作给定的二叉树，将其变换为原二叉树的镜像。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp)：递归 1.交换左右子树 2. 分别将左右子树做镜像（一二两步顺序可以调换）
- 注意，第4题对称的二叉树是判断一个二叉树是否是对称二叉树，此题是将二叉树变换为原二叉树的镜像
- [力扣101,判断二叉树是否为对称二叉树。](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)

#### 12. 二叉搜索树与双向链表
- 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### 13. 序列化二叉树
- 题目：实现两个函数，分别用来序列化和反序列化二叉树
- 思路：使用前序遍历来序列化和反序列化。只要自己写的格式对应的上即可，可以使用$符号来表示NULL,同时每个节点之间，需要添加逗号，即','进行分隔

### 二叉树信息

#### 14 二叉树的深度
- 题目：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp)：递归的思路，求左子树的深度和右子树的深度，当前深度为max(left,right)

#### 15. 二叉树中和为某一值的路径
- 题目：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
- [思路](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)：回溯法。 深度优先遍历，根节点，左子节点，右子节点（只能是先序遍历）
    - 方法一：二叉树中是否有满足目标和的路径，有的话就压入cur,压入res 
    - 递归终止条件
        1.  当前节点为叶节点，如果和为路径和为目标和，存储,在数组中删除当前节点，返回 
        2.  当前节点为叶节点，和不为目标和，删除当前节点，返回 
- **注意：**当前节点值的压入是在最开始压入（在判断是否是叶节点之前）。当前节点的弹出是在最后。（在递归了左子树和右子树之后）。
- 相关题目： [257. 二叉树的所有路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.cpp) [113.二叉树中和为目标值的所有路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)


- 回溯法，矩阵中的路径，机器人的运动范围 

## 栈和队列

### 1. [用两个栈实现队列]
### 1.5 [两个队列实现栈] （见leetcodeleetcode总结）
### 2. 包含min函数的栈
- 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp)：实现的类中有两个栈：原本的栈，以及存放每个元素的位置对应的最小数字的栈。如果压入的数字比最小栈中的元素小，就压入最小栈中，否则压入原来的最小值。

### 3. 栈的压入、弹出序列
- 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp)：模拟的栈的压入和弹出
    - 1.压入push栈中的元素，压入的同时与Pop栈中的元素对比 ，如果相同就pop,
    - 2.当将Push数组中的元素全部处理完后，对比剩下栈中的元素与pop数组中的元素并弹出
    - 3.当栈中元素全部弹出后，k应该等于popV.size() 
- 用k指向是pop数组中下一个应该弹出的数字 的下标，当所有数字都被弹出的时候，k应该等于popV.size()

## 位运算
## 逻辑运算
### 数组中只出现一次数字
- 题目：数组中除了一个数字以外其他数字都出现两次，只有这个数字出现一次
- 思路：将所有数字用二进制表示，从头异或到尾，得到的结果就是那个出现一次的数字。因为自己和自己异或是0.
### 数组中只出现一次数字-变种1
- 题目：数组中除了2个数字以外其他数字都出现两次，只有这个2数字出现一次，
- 思路：
    - 1. 从头异或到尾，得到一个结果。得到的结果为1的地方一定是这两个数字位不同的。
    - 2. 利用得到的结果与原来的每一个进行异或，将数组分为两份，那这两个数字一定在不一样的两堆中
    - 3. 与只有一个数字出现一次的情况相同
### 数组中只出现一次数字-变种2
- 题目：数组中除了一个数字以外其他数字都出现3次，只有这个数字出现一次
- 思路：所有数字变为二进制，把对应位相加（十进制），再整除3。如果一个数字出现三次，那么它的二进制表示的每一位都只出现三次，如果把所有出现三次的数字的二进制表示的每一位都加起来，那么每一位的和都能被三整除。只出现一次的那个数字的二进制表示中对应的那一位为0，否则就是1。
### 数组中只出现一次数字-变种3
- 题目：现在有40亿个无符号整数，除了一个数字之外，其他数字都出现2次，如何找到这个数字？（要求：32位无符号整数的范围是0到42亿。（题目中应该给定数字的范围。），以及内存限制。要求找出所有出现了两次的数。）
- 补充问题：如果只可以使用10M的空间，怎么找到这40亿个数字的中位数？
- 思路：使用位图，每一个数字使用两位来记录。初始化为00，出现一次改为01，出现两次为10，出现三次为11。由此可以通过遍历两次就可以得到。如果为01即为出现了一次。42亿的数字，可以用84亿位来存储。84/8 约等于10亿Byte ,约占1GB空间。 
- ~~对于补充问题，用分区间的方式处理。数字范围是42亿，长度为2MB的无符号整型占空间是8MB，42亿/2M = 2148个空间。申请一个长度为2148的数组。累加每个区间的出现次数，可以找到中位数。再开辟一个小空间 在中位数这个位置仔细查找。。什么鬼 没看懂--见左程云程序员代码.... ~~
- :warning:一个位是1bit, 1个字节是8byte, 对应关系：10亿Byte约等于1G （953MB）。在换算的时候先除以8变为Byte,再转换为G。
### 一堆数里边只有一个出现奇数次的数，其他都出现偶数次 
- 题目：一堆数里边只有一个出现奇数次的数，其他都出现偶数次 时间复杂度为On 
- 思路：开始定义一个a=0，每输入一个数就跟a异或，即a=a^n（假设输入数的变量是n），这样最后得到的a就是出现奇数次的那个数 
    - 二进制数的按位异或 

### 1. 二进制中1的个数

### 2. 判断二进制中0的个数

### 3. 二进制高位连续0的个数

## 数据流

###  [数据流中的中位数]
- 此题面试出题方法：1.求数组中中位数 2. 求数据流中位数 3. 求海量大数据中的中位数 4. 如何得到两个有序数组中的中位数（见leetcodeleetcode）
- 题目：得到一个数据流中的中位数，如果数据流中读出奇数个值，中位数就是所有数值排序之后中间的数值。如果是偶数个值，就是所有数值排序后中间两个数的平均值。要求时间复杂度：取出$O(1)$,插入$O(logn)$。
- 思路：使用一个最大堆（小的那一半），一个最小堆（大的那一半）。保证数平均地分配到两个堆中，因此数目之差不能超过1.为了实现平均分配，当总数是偶数的时候，把新数据插入到最小堆，否则插入到最大堆。
- 插入：
    - 总数是偶数时（插入到最小堆里面）//也就是说如果两个堆的和是奇数，中位数就是最小堆中最小的那个
        - 如果待插入的数比最大堆里面最大的数还要小，那么就从最大堆中替换掉，最大堆中最大的那个。再将替换出来的那个数放到最小堆中。
    - 总数是奇数的时候(插入到最大堆中)
        - 如果带插入的数比最小堆中最小的元素还要大。那么从最小堆中替换掉，最小堆中最小的那个。再将替换出的那个数放到最大堆中。
- 取出：
    - 如果和是奇数（size%2 == 1）中位数就是最小堆中最小的那个
    - 如果和是偶数，就是二者的均值。




|数据结构|插入时间复杂度|得到中位数的时间复杂度|
---|---|---|
没有排序的数组|O(1)|O(n)|
排序的数组|O(1)|O(1)|
排序的链表|O(n)|O(1)|
二叉搜索树|平均O(logn)，最差O(n)|平均O(logn)，最差O(n)|
AVL树|O(logn)|O(1)|
最大堆和最小堆|O(logn)|O(1)|

:warning: c++堆：建堆 

```make_heap(nums.begin(), nums.end(),greater<int>());//最小堆```

```最大堆make_heap(nums.begin(),nums.end(),less<int>())```

###  字符流中只出现一次的字符

## 动态规划dp

### 把数字翻译成字符串
- 题目：把给定数字翻译成字符串。0--'a' 1--'b' ... 25 --'z' 。问一个数字可能有多少种翻译。
- 思路：整体的思路像一棵树。求树有多少个叶子节点。使用一个动态数组dp 存放当前数字为止有多少种翻译的方法。
1. 把这个数字改为字符串。string a = to_string(number);
2. 使用动态规划，从头遍历到尾（也可以从尾到头），只需要遍历一遍。时间/空间复杂度O(n)，```dp[a.size()-1]``` 就是可能的翻译种数。
    - dp[0] = 1 
    - dp[i] = dp[i-1] + 1  
    - dp[i] = dp[i-1] + dp[i-2] (i>1 && {10 <= [(a[0]-'0')* 10 + (a[1] - '0')] <=25})
3. 最后返回dp[a.size()-1]

### 相似题：把字符串转换成整数（Atoi）非dp
:warning:这个题的要求是把字符串转换为整数，比如把字符串"123"转换为 123 。和把数字翻译成字符串是不一样的题。不是动态规划的题，考的是细节
- 思路：

最基本的版本：

```
enum status {kvalid = 0 , kinvalid };//用枚举 来表示该输入是否是非法的，如果输入是非法的，就设置为 kvalid 
for(int i = 0 ; i< s.size() ; i++){
if (
if(s[i] >= '0' && s[i] <= '9' ){
  number = number *10 + (s[i]-'0');
}
}
 
```

：warning : 1. 用一个全局变量来记录是否是非法输入，如果是非法输入就将全局变量设为一个特殊的标记。 2. "" 空字符串也是非法的输入 3. 如果输入为0，返回0不会修改全局变量的值。 4. '+' 号和 '-' 号 在最开始，后面跟着数字，是合法的输入。如果只有'+' '-' 号就是非法的输入 5. 用一个标记来记录是否是负数。 

- 空指针nullptr /空字符串"" /正负号/是否溢出。
- 功能测试(输入的字符串表示正数，负数和0)
- 边界值测试(最大的正整数，最小的负整数)
- 特殊输入输出(输入的字符串为空指针，空字符串，有非数字字符等)

:warning: 要在写代码之前考虑所有的可能测试用例的习惯，要严谨。:warning:




- dp 礼物的最大价值
- dp 最长不含重复字符的子字符串
- dp n个骰子的点数


### 股票的最大利润(dp) 一次买卖 
- 见leetcodeleetcode ,还有其变种题，可以买卖无数次。

### 连续数组的最大和(dp) 
- 见上方 还有**遗留** dp[i]到底存放的什么 


### 剪绳子（dp）

### 硬币，和为目标值的最少硬币的组合

给你硬币的面值数组【1 3 5】给有一个target，求出用最少硬币的组合，我写了半天，没写完，他说不应该用暴力解，要用dp

## 单调栈
### 给了一个温度数组 ，求每个数字比它大的第一个数字距离它的坐标差，也就是求每一天再过几天温度回升高。



## 递归和循环
### 1. 斐波那契数列

### 2. 跳台阶

### 3. 变态跳台阶

### 4. 矩形覆盖
## DFS 

### 2. 机器人的运动范围 深度优先遍历
- 题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够达到多少个格子？
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%9B%9E%E6%BA%AF%E6%B3%95/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.cpp)：深度优先搜索DFS(使用的是递归) ，这道题不是回溯法，向上下左右走，使用一个 flag 数组记录该点是否统计过，返回值是从该点继续搜索，可以到达的格子数目。遇到走过或者超出边界的情况就返回。
- 小技巧：计算一个数字各个位相加:

```
int getdigit(int x){
  int sum = 0 ;//注意这里sum=0 的细节 
  while(x){
    sum += x%10;
    x = x/10;
  }
  return sum; 
}
```

### DFS+回溯法
####  矩阵中的路径
矩阵中的路径属于图搜索的问题 DFS+回溯法
- 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)
深度优先搜索+回溯法 向上下左右走，用一个flag数组记录当前点是否走过，边走边记录当前字符串的长度。当走到字符串尾部时，即为找到了字符串。向下深度优先搜索，匹配了当前数字就继续向下搜，如果不是就向上回溯。
- 写一个dfs函数，返回从当前点开始继续向周边搜索，是否有满足字符串的路径。但是从每一个节点都可以开始搜索。
- **注意1：** 千万注意赋值的时候 把等号写成 == 的错误
- **注意2：** 回溯函数 要在 if 里面判断res 是否为 false (这里还是没有太懂)


### 二叉树中和为某一值的路径 
- 见上文
### 八皇后
- [题目](https://www.nowcoder.com/questionTerminal/fbf428ecb0574236a2a0295e1fa854cb)：会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。 给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。
- 思路：这是一道典型的DFS回溯题目
## 其他 

### 1. 整数中1出现的次数
- 题目：求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）
- 思路1：遍历1到n的每一个数，对于每一个数都去判断这一位是否是1。如果输入数字是n,n有O(logn)位，时间复杂度是O(nlogn),当输入的n非常大的时候，需要大量的计算。效率不高
- 思路2：不希望计算每个数字的1的个数，每次去掉最高位进行递归，递归的次数和位数相同，一个数字n有O(logn)位，时间复杂度是O(logn)


- 其他0: 如何判断一个整数有几位？（这里只考虑这个整数大于0的情况）也就是至少有一位
    - 思路：初始res = 1 如果这个数大于10，res++; x /= 10
```
int getdigit(int x ){
while(x){
int res = 1;
while(x>10){
res++;
x/=10;
}
}
return res;
}
```
- 其他1：如何判断一个数的各个位里面有几个1？
    - 思路：初始res = 0 。如果这个数大于0，就res++,然后这个数对10取余，如果余数为1说明这一位是1。
```
    int res = 0;
    while(m>0){
        if(m%10==1){
            res++;
        }
    m/=10;
    }
```
- 注意： :warning: 1出现在 10000~19999 这10000 个数字的万位中，一共出现了（$10^4$次）。1出现在万位的次数是 去除最高位之后剩下的数字加一。eg:10000~12345，中1出现在万位的次数是 2345+1。

- 例子：求1~21345中1出现的次数。分段：10000~19999 （10^4）次。
    - 1~1345  
- 把1346~21345又分成两段。除了最高位，还剩3个位置，其他的数为1的个数是：2(两组x1346~x1345) * 4（1有4个位置可以选择） * 10^3 （每个数字都可以在0~9这是个数字中选，一共选3个，有10^3 种排列组合） 合起来一共是 2* 4* 10^3 = 8000次
    - 1346~11345  
    - 11346~21345 
    
### 数字序列中某一位的数字
- 题目：求数字序列01234567891011121314...任意第n位对应的数字。
- 思路1: 枚举数字，位数累加，看位数之和是否小于等于n.先转为字符串再去求第N位。
- 思路2: 序列的前十位可以不用看，接下来10~99 有 （99-10+1）* 2 = 180 位数。剩下100~999 有（999-100）* 3 = 2700 位数
- 如果我要找第1001位数 1001 - 10 - 180 = 811 后面有2700位 三位数，用811除以3取余。得到余数，就是对应三位数的那个位数。

- 注意：10~99有多少个数？100~999有多少个数？（end-begin+1）
- m位数字加起来有多少个？ 有 m* 9* 10^(m-1) 个




### 2. 扑克牌顺子
- 题目：扑克牌有54张，里面有两张大小王，现在抽出五张牌，判断是否可能是顺子，大小王可以做癞子。大小王表示为0
- 思路：
    - 遍历第一次统计大小王的个数，也就是0的个数  
    - 从小到大排序，
    - 使用两个指针，紧挨着从从第一个不为0的数遍历到尾，并累加记录两个相邻数字之间相差的**空**（num[big]-num[small]-1）
    - 比较**空**的个数和0的个数，如果0的个数比空的个数大，说明可以是顺子，否则不行。
    
### 3. 孩子们的游戏（圆圈中剩下的数）

### 4. 替换空格 
  
### 5. 数值的整数次方

### 6. 顺时针打印矩阵

### 7. 最小的k个数(堆排序)
- 题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
- 思路1. 用sort排序
- [思路2](https://github.com/JINGbw/NewCoder/tree/master/%E6%95%B0%E7%BB%84)：最小的k个数使用堆排序，最大堆 
- 堆排序/快排


### 8. 丑数
 
## 图搜索
### 最少操作次数
### 最少操作次数的简易版
### 单词游戏（矩阵中的路径）
### 八皇后问题
### 八数码问题 （我的 跟谁学 面试题）
- 题目：在3* 3的棋盘上摆有8个棋子，每个棋子上标有 1~8 范围内某一个数字，不同棋子上标的数字不同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变为目标状态，移动棋子步数最少的移动步骤。
- 思路： 可以用BFS 广度优先搜索 或者启发式搜索A* 算法。
    - BFS广度优先搜索：每一个初始状态都对应着若干个下一时刻状态 ，比较每个下一时刻状态与目标状态是否相等。相等就找到了，不相等就继续广度优先搜索。
    


## c++

1. int 转 string 
```
to_string(x)
```
2. sort函数重写比较函数（从大到小排列）
```
static bool cmp(int x, int y){
return x>y?true:false;
}
```

3. 哈希表

```
unordered_map(int,int)res;//哈希表 
//查看哈希表中某个数字的数目：
res.count(20);
```
4. 是奇数/偶数
```
x%2 == 0 -> 是偶数 / x%2 == 1 -> 是奇数 
```
5. 复制一个数组 （把dq中的复制到array中)
```
array.assign(dq.begin(),dq.end());
```
6. 初始化数组为0 
```
int count[256] = {0};
```
7. 取字符串的子串
```
str.substr(n,len);//从下标为n的数开始，取len长度的字符串 
```
8.  c语言，矩阵
```
bool * visited = new bool[rows* cols]

memset(visited,0,rows* cols)

第[row][col]元素：表示为 visited[row* cols+col ]

delete []visited ;
```
9. 链表和树的结构体 
10. deque 是双端队列 queue是单端队列 
```
queue 基本操作

push(x) 将x压入队列的末端

pop() 弹出队列的第一个元素(队顶元素)，注意此函数并不返回任何值

front() 返回第一个元素(队顶元素)

back() 返回最后被压入的元素(队尾元素)

empty() 当队列为空时，返回true

size() 返回队列的长度

```
11. 绝对值函数 abs（left-right）;
12. 用vector建堆
```
vector make_heap(res.begin(), res.end(),greater<int>()//建堆 最小堆 如果是最大堆就是 less<int>() 

//压入
res.push_back(res.begin(), res.end())//将新元素放在堆最后
push_heap()//(压入之后排序）调整堆
//弹出
pop_heap(res.begin(), res.end()) //弹出之前排序 //将最小元素放在堆最后 
res.pop_back() //删除堆中最后的元素（最小的元素）
```
13. 空的类所占内存是1 
    - 空类的实例不包含任何信息，但是我们在声明该类型的实例的时候，必须在内存中占有一定的空间，否则就无法使用。在vs中占一个字节。
    - 如果加了构造函数和析构函数，所占空间还是1。
    - 如果析构函数设为了虚函数，如果c++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，如果是在32位的机器上，一个指针占4字节的空间，sizeof(指针) =  4 。如果是64位的机器，一个指针占8字节的空间。
    


## 暂时记在这里 with :moon:

9.7 

晚 

- 寻找两个有序数组的中位数 
    - while二分 （三个条件）
    
9.10 

早

- 数组中的逆序对（归并排序在合并的时候计算）

晚

- 扑克牌中的顺子

9.11 

晚 

- 和s的两个数字（双指针一前一后）
- 和为s的连续正数序列（双指针都从头）

9.12 

早

- 25匹马

晚 dp 写状态转移函数

- 股票的最大利润(dp) 一次买卖
- 连续数组的最大和(dp) 还有**遗留** dp[i]到底存放的什么 

9.13 

早

- 字符串中第一个只出现一次的字符 ...遗漏：字符流中只出现一次的字符
- 二叉树中和为某一值的路径（中序遍历）注意当前节点的压入和弹出时间

## 智力题
1. 一个100层的大厦，你手中有两个相同的玻璃球。从这个大厦的某一层扔下围棋子就会碎，用你手中的这两个玻璃围棋子，找出一个最优的策略，来得知那个临界层面。 [思路](https://blog.csdn.net/xflame/article/details/9763317)

--百度

2. 25匹马，一次

3. 

4. 

5. 

**计划**

与已经复习了的相关题目：

- ...遗漏：字符流中只出现一次的字符
- 股票只能买卖两次

晚

待处理：dp和回溯
- dp 礼物的最大价值
- dp 最长不含重复字符的子字符串
- dp n个骰子的点数
- 学姐京东 二叉树中两个节点的最近父节点
- atoi

- 在排序数组中查找数字 
    - 1. 数字在排序树组中出现的次数
    - 2. 0~ n-1 中缺失的数字
    - 3. 数组中数之和下标相等的元素
    
[emoji-list](https://github.com/caiyongji/emoji-list)

