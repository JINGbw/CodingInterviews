
Table of Contents
=================

   * [NowCoder](#nowcoder)
      * [数组](#数组)
         * [数组查找](#数组查找)
            * [1. 二维数组的查找](#1-二维数组的查找)
            * [3. 数组中重复的数字](#3-数组中重复的数字)
            * [4. 连续子数组的最大和](#4-连续子数组的最大和)
            * [5. 旋转数组的最小数字](#5-旋转数组的最小数字)
            * [6. 数组中出现次数超出一半的数字](#6-数组中出现次数超出一半的数字)
            * [7. 数组中的逆序对](#7-数组中的逆序对)
         * [数组排序](#数组排序)
            * [8. 把数组排成最小的数](#8-把数组排成最小的数)
            * [9. 调整数组顺序使奇数位于偶数前面](#9-调整数组顺序使奇数位于偶数前面)
         * [数组其他](#数组其他)
            * [10. 构建乘积数组](#10-构建乘积数组)
            * [11. 顺时针打印矩阵](#11-顺时针打印矩阵)
            * [12. 矩阵中的路径](#12-矩阵中的路径)
      * [字符串](#字符串)
         * [字符串常规](#字符串常规)
            * [1. 替换空格](#1-替换空格)
            * [2. 正则表达式匹配](#2-正则表达式匹配)
            * [3. 表示数值的字符串](#3-表示数值的字符串)
            * [4. 第一个只出现一次的字符位置（字符串中第一个不重复的字符）](#4-第一个只出现一次的字符位置字符串中第一个不重复的字符)
            * [5. 字符流中第一个不重复的字符](#5-字符流中第一个不重复的字符)
            * [6. 字符串的排列（全排列）](#6-字符串的排列全排列)
            * [7. 翻转字符串](#7-翻转字符串)
            * [8. 左旋转字符串](#8-左旋转字符串)
            * [9. 最长不含重复字符的子字符串](#9-最长不含重复字符的子字符串)
      * [链表](#链表)
         * [链表结点](#链表结点)
            * [1. 链表中倒数第k个结点](#1-链表中倒数第k个结点)
            * [2. 链表中环的入口节点](#2-链表中环的入口节点)
            * [3. 两个链表的第一个公共结点](#3-两个链表的第一个公共结点)
            * [4. 删除链表中重复的结点](#4-删除链表中重复的结点)
         * [链表打印/转换](#链表打印转换)
            * [5. 从尾到头打印链表](#5-从尾到头打印链表)
            * [6. 反转链表](#6-反转链表)
            * [7. 二叉搜索树与双向链表](#7-二叉搜索树与双向链表)
            * [8. 合并两个排序的链表](#8-合并两个排序的链表)
            * [9. 链表回文结构](#9-链表回文结构)
            * [10. 把字符串转换成整数(Atoi)](#10-把字符串转换成整数atoi)
            * [11. 复杂链表的复制](#11-复杂链表的复制)
      * [树](#树)
      * [Trie树](#trie树)
      * [哈夫曼树](#哈夫曼树)
         * [二叉树遍历，打印](#二叉树遍历打印)
            * [1. 按之字形顺序打印二叉树](#1-按之字形顺序打印二叉树)
            * [2. 把二叉树打印成多行（二叉树的层次遍历）](#2-把二叉树打印成多行二叉树的层次遍历)
            * [3. 从上往下打印二叉树](#3-从上往下打印二叉树)
         * [二叉树判断](#二叉树判断)
            * [4. 对称的二叉树](#4-对称的二叉树)
            * [5. 平衡二叉树](#5-平衡二叉树)
            * [6. 树的子结构](#6-树的子结构)
            * [7. 二叉树的后序遍历序列](#7-二叉树的后序遍历序列)
         * [二叉树结点相关](#二叉树结点相关)
            * [8. 二叉搜索树的第k个结点](#8-二叉搜索树的第k个结点)
            * [9. 二叉树的中序遍历下一个结点](#9-二叉树的中序遍历下一个结点)
         * [根据输入重建二叉树 （输入数组，输出二叉树 ）](#根据输入重建二叉树-输入数组输出二叉树-)
            * [10. 重建二叉树](#10-重建二叉树)
         * [二叉树变换（输入二叉树，输出二叉树/序列 ）](#二叉树变换输入二叉树输出二叉树序列-)
            * [11.  二叉树的镜像](#11--二叉树的镜像)
            * [12. 二叉搜索树与双向链表](#12-二叉搜索树与双向链表)
            * [13. 序列化二叉树](#13-序列化二叉树)
         * [二叉树信息](#二叉树信息)
            * [14 二叉树的深度](#14-二叉树的深度)
            * [15. 二叉树中和为某一值的路径](#15-二叉树中和为某一值的路径)
      * [栈和队列](#栈和队列)
         * [1. [用两个栈实现队列]](#1-用两个栈实现队列)
         * [2. 包含min函数的栈](#2-包含min函数的栈)
         * [3. 栈的压入、弹出序列](#3-栈的压入弹出序列)
      * [位运算](#位运算)
         * [1. [二进制中1的个数]](#1-二进制中1的个数)
         * [2. [判断二进制中0的个数]](#2-判断二进制中0的个数)
         * [3. [二进制高位连续0的个数]](#3-二进制高位连续0的个数)
      * [数据流](#数据流)
         * [[数据流中的中位数]](#数据流中的中位数)
         * [[字符流中只出现一次的字符]](#字符流中只出现一次的字符)
      * [递归和循环](#递归和循环)
         * [1. [斐波那契数列]](#1-斐波那契数列)
         * [2. [跳台阶]](#2-跳台阶)
         * [3. [变态跳台阶]](#3-变态跳台阶)
         * [4. [矩形覆盖]](#4-矩形覆盖)
      * [回溯法](#回溯法)
         * [1. 矩阵中的路径](#1-矩阵中的路径)
         * [2. [机器人的运动范围]](#2-机器人的运动范围)
         * [[二叉树中和为某一值的路径]](#二叉树中和为某一值的路径)
         * [全排列](#全排列)
         * [字符串的排列，全排列](#字符串的排列全排列)
         * [二叉树中和为某一值的路径](#二叉树中和为某一值的路径-1)
         * [八皇后](#八皇后)
      * [其他](#其他)
         * [1. <a href="从1到n中的整数中1出现的次数">整数中1出现的次数</a>](#1-整数中1出现的次数)
         * [2. 扑克牌顺子](#2-扑克牌顺子)
         * [3. 孩子们的游戏（圆圈中剩下的数）](#3-孩子们的游戏圆圈中剩下的数)
         * [4. 替换空格](#4-替换空格)
         * [5. 数值的整数次方](#5-数值的整数次方)
         * [6. 顺时针打印矩阵](#6-顺时针打印矩阵)
         * [7. 最小的k个数(堆排序)](#7-最小的k个数堆排序)
         * [8. 丑数](#8-丑数)
      * [c  ](#c)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)


****
# NowCoder
剑指Offer 66题刷题笔记
 
## 数组

### 数组查找 

#### 1. 二维数组的查找

- 题目：二维数组从左到右依次变大，从上到下依次变大，找到目标数字
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE.cpp)：法一：利用二分法找到该数所在的行，再用二分法找到这个数。法二：从左下角或者右上角开始找，可以根据Target与当前元素的大小关系来缩小查找区间


#### 3. 数组中重复的数字
- 题目：找到数组中任意一个重复的数字
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.cpp)：如果第i个数不等于i,就把第i个数换到i的位置去，如果第i个数那个数的位置 等于那个数，就说明找到了重复的数字


#### 4. 连续子数组的最大和

题目：找到给定数组中连续子数组的最大和
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp)：动态规划的状态转移方程：
    - dp[i] = array[0] , (i = 0 ) 
    - dp[i] = max(dp[i-1]+array[i],array[i]); (i = 1,2 ,3 ... n-1) 

- （力扣）上有一题是求最长上升子序列的长度，不要搞混了 


#### 5. 旋转数组的最小数字
- 相关：[在旋转数组中寻找目标数字]

#### 6. 数组中出现次数超出一半的数字
- 相关：[数组中出现次数等于一半的数字]
- 题目： 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。**如果不存在则输出0。**
- 思路：使用两个数字，用一个数记录数组中的一个数字，一个是次数，
    - 如果下一个数字与保存的数字是一样的，则次数加1，如果不同，就次数减一，如果次数为0，
    - 就保存下一个数字，把次数设为1，因为我们要找的数字出现的次数比其它全部数字的出现次数之和还要大，则要找的数字肯定是组后一次把次数设为1时相应的数字。该方法的时间复杂度为O(n)，空间复杂度为O(1)。
- 注意： 由于不存在要输出0，所以最后还要遍历一遍数组，统计该数字出现的次数。
- 总结：如果可以修改数组，可以使用partition(快排)的方法，如果不可以修改数组，就使用这种方法
- 变种题：寻找出现次数等于n/2的数字
    - 上一种解法在数字个数为偶数的时候就失效了。修改方法为：在数组中随便找一个数字，再对剩下的数字做刚刚的操作
    - 对比这个数字，和最后得到的数字，再遍历两遍原数组（一共遍历了三次数组复杂度为3n）

#### 7. 数组中的逆序对
- 题目：在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
- 思路：归并排序，二分。在归并排序的合并阶段统计逆序对的个数。
    - 现在有两个已经排好序（从小到大）的数组A和数组B ，使用两个指针从两个数组的最后一个元素指。i为数组A中最后一个元素的下标，j为数组B中最后一个元素的下标。
    - 如果A[i]>A[j],说明A[i]大于从A[mid+1]（A中的第一个元素）到A[j]的每一个元素，逆序对count+= (j-(mid+1))+1也就是  count+= j-mid ;


### 数组排序

#### 8. 把数组排成最小的数

- 题目：把数组（int类型）里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0.cpp)：1.重新定义排序函数中调用的比较函数cmp 并排序 2. 将排好序的数组拼接起来返回
 
   
#### 9. 调整数组顺序使奇数位于偶数前面

- 题目：调整数组中数字的顺序，使奇数在偶数前面
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2.cpp)：1.奇数放在前半部分，从原来数组的后面开始找 ,从前面插入到双端队列 2.偶数放在后半部分，从前开始找，插入双端队列的后面 

### 数组其他
#### 10. 构建乘积数组

- 题目：给定数组A[0,1,...n-1]，要求构建B[0,1,...n-1],其中B的元素B[i] = A[0]A[1]...A[i-1]A[i+1]...A[n-1]。要求不能使用除法
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84.cpp)：循环B数组两遍，将B中结果拆成两部分乘积，一部分是下三角形，一部分是上三角形。
    -  B[0] = 1 ,i从1到n-1 ,$B[i]=B[i-1]* A[i-1]$ 
    -  i从n-2到0 ，$ tmp*= A[i+1], B[i] = B[i]* tmp$
 


#### 11. 顺时针打印矩阵

- 题目：按照顺时针的顺序打印出矩阵中的每一个数字 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5.cpp)：
    1. 从左到右
    2. 从上到下 判断跳出条件 top==bottom
    3. 从右到左 right == left
    4. 从下到上 top = bottom-1 
- 注意循环截止条件 （3.4.的时候考虑）(只有一行或者一列的情况)

#### 12. 矩阵中的路径
- 题目：矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)：使用一个bool矩阵记录矩阵的当前位置是否走过，使用一个变量pathlength记录走到了字符串的哪个位置 。
    -  对于数组中的每一个位置，都调用递归函数，从数组第row,col这个位置开始找，是否有字符串第pathlenhgth(包含这个位置，及以后的子串)
    -  如果当前位置没有超出范围，且当前位置没走过，且当前位置等于字符串pathlength元素，进入函数 
- 注：如果形参未引用，那么实参不能在传参时进行加减。需要先计算好再传入


## 字符串
### 字符串常规
#### 1. 替换空格
- 题目：请实现一个函数，将一个字符串中的每个空格替换成“%20”
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.cpp)：1. 遍历字符串，统计字符串的空格个数和非空格个数，得到替换后的长度      2. 从后往前替换，如果是空格就换为“%20”

#### 2. 正则表达式匹配

#### 3. 表示数值的字符串

#### 4. 第一个只出现一次的字符位置（字符串中第一个不重复的字符）
- 题目：找到字符串中一个只出现一次的字符位置
- 思路：使用哈希表 （或者长度为256的数组做哈希表） 1. 遍历一遍，使用哈希表记录每个字符出现的次数 2. 再遍历一遍，如果只出现一次，返回

#### 5. 字符流中第一个不重复的字符
- 题目：找到字符流中第一个不重复的字符（两个函数 ，一个用于向字符流中插入字符，一个用于找到第一个不重复的字符）
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6.cpp)：1. 使用string s 记录该字符流 2. 使用哈希表（长度为256），初始化为-1，如果出现一次，occur[i]记录为它再字符流中的位置，没有出现过是-1 ，出现超过一次，出现过多次记录为-2。

（还有字符串中第一个不重复的字符 用哈希表来做（长度为256的数组，记录每个字符出现的次数））O(n)

#### 6. 字符串的排列（全排列）
- 题目：输入字符串求全排列
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%EF%BC%88%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%89.cpp)：递归让每个数字当第一个，循环截止条件：递归到了最后一个数字/每次递归结束后再换回来。
    - 递归函数：```void core(string str,   vector<string>  &res , int  num )```
    - 递归的条件：1. 当前数字是第一个或者当前值与第一个值不等才会交换和递归
    - 传进去的数字是记录对字符串从第（num）个数，到最后一个数进行全排列。
    
 
#### 7. 翻转字符串

- 题目：将英文句子中的单词顺序翻转，但是单词内字符的顺序不变
- 思路：1. 在原字符串后加空格，作为标记，以空格为标记，翻转每个子单词 2. 删除单词，翻转整个字符串 

#### 8. 左旋转字符串

- 题目：左旋转字符串ROL ，将string str左移n位 
- 思路1 ：相当于在原来的字符串后面再加上一个原来的字符串，取新字符串的 .substr(n, len);//n= n%len 
- 思路2 ：利用上面翻转字符串的思路，先翻转前面n个，再翻转整个字符串。

#### 9. 最长不含重复字符的子字符串

## 链表

### 链表结点

#### 1. 链表中倒数第k个结点
- 题目：输入一个链表，输出该链表中倒数第k个结点。
- 思路：一个指针先向前走k-1步，两个指针再一起向前走，前面的指向空了，就找到了倒数第k个结点。

#### 2. 链表中环的入口节点
- 题目：找到链表中环的入口节点
- 思路：
    - 法一：1. 使用两个指针，一个比另一个速度快一步，两个一起向前走，如果相遇，相遇点一定在环中。2. 使用两个指针，一个从相遇处开始走，一个从头节点开始走，如果再次相遇，相遇点就是环的入口
    - 法二：1.同上 2. 在第一步相遇后，使用一个节点记录相遇处，另一个节点在环中绕一圈，就可以得到环的长度。3. 得到环的长度后，使用两个指针，一个先走环的长度，两个指针再一起走。
    
#### 3. 两个链表的第一个公共结点
- 题目：输入两个链表，找出它们的第一个公共结点。
- 思路：因为都是单链表，两个链表一旦相交就不会分开了。
    - 法一：1. 先分别遍历两个链表，得到两个链表的长度 2. 比较长的链表先走（两个链表长度的差值）再一起向前走，直到相遇
    - 法二：1. 使用两个指针，一个从链表A开始走，如果走到了尾部，就从B的头部重新开始访问B 。另一个从链表B开始走，如果走到尾部就从链表A的头部重新开始访问。当两个指针相遇的时候，就是两个链表的第一个公共结点。 
    
#### 4. 删除链表中重复的结点
- 题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E9%93%BE%E8%A1%A8/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9.cpp)：使用三个指针，pre,cur,next ,pre指向不重复的最后一个，cur指向重复的第一个，next指向重复的最后一个
     - 如果cur和它下一个一样，就用next向后找，走到最后一个重复的节点。
     - 如果cur是第一个节点，就删除cur到next,将指向第一个元素的指针指向pHead  
         
    
### 链表打印/转换 

#### 5. 从尾到头打印链表
- 题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。
- 思路：法一：使用栈或者递归 
    - 法二：使用头插法构建逆序链表
    
#### 6. 反转链表
- 题目：原地翻转链表 输出新链表的表头 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.cpp)：使用四个指针 pre,cur,next,newhead 

- 反转链表的一部分
- 题目：反转链表中的部分节点，使用一趟扫描完成反转（第m个到第n个）
- [思路](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E9%93%BE%E8%A1%A8/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II.cpp)：使用三个指针pre,cur,nt 反转链表 。时间复杂度：O(N)。空间复杂度：O(1)
    -  一个指针向前走m-1步走到第一个待翻转的结点。pre指向待反转的前一个结点
    -  cur指向待反转的第一个节点 ， 一次翻转 cur 和 next 两个 ，一直到n
    -  修改每个指针的->next 先修改cur,再next，最后Pre 
    

#### 7. 二叉搜索树与双向链表
- 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.cpp)：二叉搜索树的中序遍历是从大到小排列的，由于转换要求是排好序的，所以使用中序遍历
    - 当前节点为空则返回
    - 当前节点是否有左节点，有的话就递归
    - 当前节点左指向递归结果
    - 当前递归结果如果不为空，递归结果指向当前节点
    - 当前节点是否有右节点，有的话就递归
- 这里注意一级指针和二级指针的转换 




#### 8. 合并两个排序的链表
- 题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
- 思路：1. 如果一个为空就直接返回另一个 2. 利用递归的方法，两个链表头节点中比较小的，下一个结点接上递归调用剩下的。

#### 9. 链表回文结构

#### 10. 把字符串转换成整数(Atoi)

#### 11. 复杂链表的复制
- 题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。next指针，random指针，val 
- 思路：1. 在原来链表每个节点后面插入复制的节点，复制next和val 2. 复制random 3. 将一个链表拆成两个 
- 注意：如何将一个链表拆成两个，（先用一个指针指向拆开后的头结点）。
     - p1是原来链表的指针，先让p1向前走一步，循环终止条件是p1不为空。
## 树

1. 完全二叉树：堆就是由完全二叉树组成的，前n-1层全满，第n层只有右边可以是空的。
2. 满二叉树： 树中每个分支结点都有2棵非空子树。
3. 二叉搜索树： 二叉搜索树的所有左子节点的值都小于右子节点的值。
4. AVL树：AVL树是最早被发明的自平衡二叉查找树。 在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。 查找、插入和删除在平均和最坏情况下的時間複雜度都是 。 增加和删除元素的操作则可能需要藉由一次或多次树旋转，以实现树的重新平衡。
## Trie树
- Trie树 ，字典树，又称单词查找树，是一种树形结构，常用于统计和排序大量字符串等场景中，经常被搜索引擎用于文本词频统计，它的有点事最大限度地减少无畏的字符串比较，查询效率比较高。三个基本性质
    - 根节点不包含字符，除根节点外，每个节点只包含一个字符
    - 从根节点到某一节点的路径上经过的字符连接起来，即为该节点对应的字符串。如果某个节点被标记为红色，表示这个单词存在，否则不存在，对于一个单词，只要顺着它的根节点走到对应的节点，再看看这个结点是否被标记为红色就知道这个
    - 每个节点的所有子节点包含的字符都不同
- 数据结构：Trie 树可以用动态链表和数组来模拟动态，空间的花费不会超过单词数乘以单词的长度。也可以用堆来实现。
- 时间复杂度：n个单词，平均长度为len
    - 统计：使用Trie树来统计每个词出现的次数，时间复杂度是O(N * len)
    - 查找：找出其中出现最频繁的10个词：时间复杂度：O(Nlog10)
- [Trie树的应用](https://www.cnblogs.com/lisen10/p/10922670.html)：
    - 字符串检索 检索/查询功能是Trie树最原始的功能。给定一组字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较：如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。
    - 词频统计 为了实现词频统计，我们修改了节点结构，用一个整型变量count来计数  对每一个关键字执行插入操作，若已存在，计数加1，若不存在，插入后count置1。
    - 排序
    - 前缀匹配
    - 最长公共前缀
    - 作为辅助结构
- 应用实例
    - 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
    - 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。
    - 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。请怎么设计和实现？
    - 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
    - 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。
- Trie树的实现
    - Trie树的插入、删除、查找的操作都是一样的，只需要简单的对树进行一遍遍历即可，时间复杂度：O(n)（n是字符串的长度）。
    - 数组： 由于我们知道一个Tried树节点的子节点的数量是固定26个（针对不同情况会不同，比如兼容数字，则是36等），所以可以使用固定长度的数组来保存节点的子节点
        - 优点：在对子节点进行查找时速度快
        - 缺点：浪费空间，不管子节点有多少个，总是需要分配26个空间
    - 链表：使用链表的话我们需要在每个子节点中保存其兄弟节点的链接，当我们在一个节点的子节点中查找是否存在一个字符时，需要先找到其子节点，然后顺着子节点的链表从左往右进行遍历
        - 优点：节省空间，有多少个子节点就占用多少空间，不会造成空间浪费
        - 缺点：对子节点进行查找相对较慢，需要进行链表遍历，同时实现也较数组麻烦
## 哈夫曼树
- 给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

**基本术语**
哈夫曼树又称为最优树.
**1、路径和路径长度**
在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
**2、结点的权及带权路径长度**
若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
**3、树的带权路径长度**
树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL

**霍夫曼树有什么好处呢？**一般得到霍夫曼树后我们会对叶子节点进行霍夫曼编码，由于权重高的叶子节点越靠近根节点，而权重低的叶子节点会远离根节点，这样我们的高权重节点编码值较短，而低权重值编码值较长。这保证的树的带权路径最短，也符合我们的信息论，即我们希望越常用的词拥有更短的编码。如何编码呢？一般对于一个霍夫曼树的节点（根节点除外），可以约定左子树编码为0，右子树编码为1。



## 二叉树 
### 二叉树遍历，打印 

#### 1. 按之字形顺序打印二叉树
- （类似层次遍历）
- 题目：请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：使用两个栈stack<int>s[2]，一个栈先存左子树的根节点，一个栈先存右子树的根节点。 两个数组vector<int>v[2]
     1. 0 2 4 6 层压入 s[0] v[0]、 1 3 5 7层使用 s[1] v[1]
     2. 从s[0]中取出，向s[1]中先压入左结点的再压入右结点（因为取出的时候是右边的先出来）。将s[0]的取出压入v[0]中
     3. 如果v[0]非空，就把v[0]中的压入到res中
     4. 从s[1]中取出，向s[0]中先压入右结点再压入左节点（取出的时候先取出左边的）。将s[1]的取出压入v[1]中
     5. 如果v[1]中非空，就把v[1]的压入到res中
 
#### 2. 把二叉树打印成多行（二叉树的层次遍历）
- （层次遍历 BFS） 辅助： 队列 
- 题目：从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。返回vector<vector<int> >
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C.cpp)：使用两个队列。树的层次遍历，使用队列。
    - 使用两个队列，和两个数组。第一个队列出来后，下一层的数据按照从左到右的顺序放入第二个队列，先进先出，出来的顺序也是从左到右。
    - 只要两个队列有一个不为空就进入循环
    - 新建两个数组12（存放从栈中取出来的值）
    - 如果队列1不为空，取出队列头的值放到数组1中，把左右根节点放到栈2里，再弹出栈1的队列头元素。
    - 把数组1 中的值放到二维矩阵里面。
    - 队列二同理。
- 思路2：每次记录下来当前队列中的树节点个数，将这些树木的节点存入tmpvector中。并顺便压入每个节点的左节点和右节点。
 
#### 3. 从上往下打印二叉树
- （层次遍历 BFS）
- 题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。 （不分行）
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：不需要使用两个队列来存储当前层的节点和下一层的节点，因为在开始遍历第一层的节点时，当记录下来当前队列中的元素个数，前队列中的节点数就是当前层的节点数，就能保住这次遍历的都是当前层的节点。 
    - 使用一个队列和一个数组。
- 与上题的区别是，上题要求打印出多行，此题返回一行  vector<int> 

### 二叉树判断

#### 4. 对称的二叉树

- 题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：调用递归函数，输入是两个树的根节点，返回这两棵树是否是对称的
    - 1. 如果都为空是对称的，2. 如果一个空，一个不空false 3. 如果根节点不等返回false 4. 递归，输入
    - 通常有三种不同的二叉树遍历算法，即前序遍历，中序遍历和后序遍历，在这三种遍历算法中，都是先遍历左节点再遍历右节点，一前序遍历为例，我们可以定义一个遍历算法，先遍历右子节点再遍历左子节点，暂且称其为前序遍历的对称遍历。通过比较二叉树的前序遍历序列（根左右），和对称前序遍历序列（根右左），将遍历时遇到的nullptr指针也考虑进来。
- 注意：要考虑，一个子树为空，一个子树不为空，返回false的情况。

#### 5. 平衡二叉树

- 题目:输入一棵二叉树，判断该二叉树是否是平衡二叉树。平衡二叉树的定义是左右子树的高度差不超过1。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)：定义递归函数，判断当前二叉树是否平衡，顺便求树的深度。思路是计算左右子树的深度，如果高度差大于1说明不平衡。
- 相关题目：计算二叉树的深度


#### 6. 树的子结构
- 题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84.cpp)：
    - 1. 在树A中找与树B 根节点值相同的节点。找到相同节点后，调用函数判断两个相同根节点的树，树2是不是树1的子结构。
    - 2. 输入两棵树的根节点（根节点相同）在两棵树根节点相同的情况下，判断两棵树是否相等。循环截止条件：根节点的值不相等。
- 注意：空树不是任何树的子树


#### 7. 二叉树的后序遍历序列
- 题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.cpp)：后序遍历序列的最后一个元素是根节点 ，二叉搜索树的左子树所有节点都比根节点小，右子树都比根节点大
    1. 从后序遍历的第一个元素开始，找到比最后一个元素大的第一个元素，下标为i,这个元素左边[0,i-1]的应该是左子树
    2. 从第i个元素一直到第n-1个元素是右子树，所有节点的值应该小于根节点的值，如果比根节点的值大，返回false;
    3. 递归左子树 (.begin(),.begin()+i)
    4. 递归右子树 (.begin()+i , .end()-1)
-  注意：数组的.end() 指的是最后一个元素后面一个位置 

###  二叉树结点相关 

#### 8. 二叉搜索树的第k个结点
- 题目：给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9.cpp)：使用中序遍历的递归形式。注意：二叉搜索树的中序遍历是升序的。时间：O(K) 空间：O(1)
    - k作为变量，使用引用传递放在递归函数的形参中，每一次递归, 如果当前节点不是第k个，那么k--;知道k==1返回当前根节点。
- 注意：将k进行引用传递是为了记录访问的节点个数，也可以使用全局变量index记录访问的节点个数，就不用另外写一个递归函数了。


#### 9. 二叉树的中序遍历下一个结点
- 题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
- 思路：1.当前节点为空（右）
    - 2. 当前节点有右节点，下一个节点是当前节点的右子树的最左节点（根）
    - 3. 否则，向上找第一个左节点指向的树包含该节点的祖先节点（左）

- 数据流中位数
- 如何得到一个数据流中的中位数


 ### 根据输入重建二叉树 （输入数组，输出二叉树 ）    
 
 #### 10. 重建二叉树
- 题目：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
- 思路：递归函数的输入是前序遍历和中序遍历的两个数组，以及两个数组中的范围，返回树的根节点。
    - 1. 前序遍历的第一个节点是根节点，在中序遍历中寻找到这个节点，利用这个值将中序遍历结果分为两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历结果。
    - 2. 求出中序遍历左半边的长度m,在前序遍历后面截取长度m,递归得调用得到左半边根节点和右半边根节点
    
### 二叉树变换（输入二叉树，输出二叉树/序列 ）    

#### 11.  二叉树的镜像
- 题目：操作给定的二叉树，将其变换为原二叉树的镜像。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F.cpp)：递归 1.交换左右子树 2. 分别将左右子树做镜像（一二两步顺序可以调换）
- 注意，第4题对称的二叉树是判断一个二叉树是否是对称二叉树，此题是将二叉树变换为原二叉树的镜像
- [力扣101,判断二叉树是否为对称二叉树。](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp)

#### 12. 二叉搜索树与双向链表
- 题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

#### 13. 序列化二叉树
- 题目：实现两个函数，分别用来序列化和反序列化二叉树
- 思路：使用前序遍历来序列化和反序列化。只要自己写的格式对应的上即可，可以使用$符号来表示NULL,同时每个节点之间，需要添加逗号，即','进行分隔

### 二叉树信息

#### 14 二叉树的深度
- 题目：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6.cpp)：递归的思路，求左子树的深度和右子树的深度，当前深度为max(left,right)

#### 15. 二叉树中和为某一值的路径
- 题目：输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)
- [思路](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)：回溯法。 深度优先遍历，根节点，左子节点，右子节点（只能是先序遍历）
    - 方法一：二叉树中是否有满足目标和的路径，有的话就压入cur,压入res 
    - 递归终止条件
        1.  当前节点为叶节点，如果和为路径和为目标和，存储,在数组中删除当前节点，返回 
        2.  当前节点为叶节点，和不为目标和，删除当前节点，返回 
        
- 相关题目： [257. 二叉树的所有路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.cpp) [113.二叉树中和为目标值的所有路径](https://github.com/JINGbw/LeetcodeLeetcode/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.cpp)


- 回溯法，矩阵中的路径，机器人的运动范围 

## 栈和队列

### 1. [用两个栈实现队列]
### 1.5 [两个队列实现栈] （见力扣总结）
### 2. 包含min函数的栈
- 题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88.cpp)：实现的类中有两个栈：原本的栈，以及存放每个元素的位置对应的最小数字的栈。如果压入的数字比最小栈中的元素小，就压入最小栈中，否则压入原来的最小值。

### 3. 栈的压入、弹出序列
- 题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97.cpp)：模拟的栈的压入和弹出
    - 1.压入push栈中的元素，压入的同时与Pop栈中的元素对比 ，如果相同就pop,
    - 2.当将Push数组中的元素全部处理完后，对比剩下栈中的元素与pop数组中的元素并弹出
    - 3.当栈中元素全部弹出后，k应该等于popV.size() 
- 用k指向是pop数组中下一个应该弹出的数字 的下标，当所有数字都被弹出的时候，k应该等于popV.size()

## 位运算
## 逻辑运算
### 数组中只出现一次数字
- 题目：数组中除了一个数字以外其他数字都出现两次，只有这个数字出现一次
- 思路：将所有数字用二进制表示，从头异或到尾，得到的结果就是那个出现一次的数字。因为自己和自己异或是0.
### 数组中只出现一次数字-变种1
- 题目：数组中除了2个数字以外其他数字都出现两次，只有这个2数字出现一次，
- 思路：
    - 1. 从头异或到尾，得到一个结果。得到的结果为1的地方一定是这两个数字位不同的。
    - 2. 利用得到的结果与原来的每一个进行异或，将数组分为两份，那这两个数字一定在不一样的两堆中
    - 3. 与只有一个数字出现一次的情况相同
### 数组中只出现一次数字-变种2
- 题目：数组中除了一个数字以外其他数字都出现3次，只有这个数字出现一次
- 思路：所有数字变为二进制，把对应位相加（十进制），再整除3。如果一个数字出现三次，那么它的二进制表示的每一位都只出现三次，如果把所有出现三次的数字的二进制表示的每一位都加起来，那么每一位的和都能被三整除。




### 1. [二进制中1的个数]

### 2. [判断二进制中0的个数]

### 3. [二进制高位连续0的个数]

## 数据流

###  [数据流中的中位数]
- 此题面试出题方法：1.求数组中中位数 2. 求数据流中位数 3. 求海量大数据中的中位数 4. 如何得到两个有序数组中的中位数




###  [字符流中只出现一次的字符]
  
## 递归和循环
### 1. [斐波那契数列]

### 2. [跳台阶]

### 3. [变态跳台阶]

### 4. [矩形覆盖]
## DFS 
### DFS+回溯法
####  矩阵中的路径

矩阵中的路径属于图搜索的问题

- 题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E6%95%B0%E7%BB%84/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84.cpp)
深度优先搜索+回溯法 向上下左右走，用一个flag数组记录当前点是否走过，边走边记录当前字符串的长度。当走到字符串尾部时，即为找到了字符串。向下深度优先搜索，匹配了当前数字就继续向下搜，如果不是就向上回溯。
- 写一个dfs函数，返回从当前点开始继续向周边搜索，是否有满足字符串的路径。但是从每一个节点都可以开始搜索。
- **注意1：** 千万注意赋值的时候 把等号写成 == 的错误
- **注意2：** 回溯函数 要在 if 里面判断res 是否为 false (这里还是没有太懂)


### 2. [机器人的运动范围]
- 题目：地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。请问该机器人能够达到多少个格子？
- [思路](https://github.com/JINGbw/NewCoder/blob/master/%E5%9B%9E%E6%BA%AF%E6%B3%95/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4.cpp)：深度优先搜索DFS(使用的是递归) ，这道题不是回溯法，向上下左右走，使用一个 flag 数组记录该点是否统计过，返回值是从该点继续搜索，可以到达的格子数目。遇到走过或者超出边界的情况就返回。
- 小技巧：计算一个数字各个位相加:

```
int getdigit(int x){
  int sum = 0 ;//注意这里sum=0 的细节 
  while(x){
    sum += x%10;
    x = x/10;
  }
  return sum; 
}
```

### [二叉树中和为某一值的路径]
### 全排列
- 
### 

### 字符串的排列，全排列
### 二叉树中和为某一值的路径
### 八皇后
- [题目](https://www.nowcoder.com/questionTerminal/fbf428ecb0574236a2a0295e1fa854cb)：会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。 给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。
- 思路：这是一道典型的DFS回溯题目
## 其他 

### 1. [整数中1出现的次数](从1到n中的整数中1出现的次数)

### 2. 扑克牌顺子
- 题目：扑克牌有54张，里面有两张大小王，现在抽出五张牌，判断是否可能是顺子，大小王可以做癞子。大小王表示为0
- 思路：
    - 遍历第一次统计大小王的个数，也就是0的个数  
    - 从小到大排序，
    - 使用两个指针，紧挨着从从第一个不为0的数遍历到尾，并累加记录两个相邻数字之间相差的**空**（num[big]-num[small]-1）
    - 比较**空**的个数和0的个数，如果0的个数比空的个数大，说明可以是顺子，否则不行。
    
### 3. 孩子们的游戏（圆圈中剩下的数）

### 4. 替换空格 
  
### 5. 数值的整数次方

### 6. 顺时针打印矩阵

### 7. 最小的k个数(堆排序)
- 题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。
- 思路1. 用sort排序
- [思路2](https://github.com/JINGbw/NewCoder/tree/master/%E6%95%B0%E7%BB%84)：最小的k个数使用堆排序，最大堆 
- 堆排序/快排

### 和为s的数字
- 题目：输入递增排序的数组，一个数字s。在递增排序的数组中
### 8. 丑数
 
## 图搜索
### 最少操作次数
### 最少操作次数的简易版
### 单词游戏（矩阵中的路径）
### 八皇后问题
### 八数码问题 （我的 跟谁学 面试题）
- 题目：在3* 3的棋盘上摆有8个棋子，每个棋子上标有 1~8 范围内某一个数字，不同棋子上标的数字不同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变为目标状态，移动棋子步数最少的移动步骤。
- 思路： 可以用BFS 广度优先搜索 或者启发式搜索A* 算法。
    - BFS广度优先搜索：每一个初始状态都对应着若干个下一时刻状态 ，比较每个下一时刻状态与目标状态是否相等。相等就找到了，不相等就继续广度优先搜索。
    


## c++

1. int 转 string 
```
to_string(x)
```
2. sort函数重写比较函数（从大到小排列）
```
static bool cmp(int x, int y){
return x>y?true:false;
}
```

3. 哈希表

```
unordered_map(int,int)res;//哈希表 
//查看哈希表中某个数字的数目：
res.count(20);
```
4. 是奇数/偶数
```
x%2 == 0 -> 是偶数 / x%2 == 1 -> 是奇数 
```
5. 复制一个数组 （把dq中的复制到array中)
```
array.assign(dq.begin(),dq.end());
```
6. 初始化数组为0 
```
int count[256] = {0};
```
7. 取字符串的子串
```
str.substr(n,len);//从下标为n的数开始，取len长度的字符串 
```
8.  c语言，矩阵
```
bool * visited = new bool[rows* cols]

memset(visited,0,rows* cols)

第[row][col]元素：表示为 visited[row* cols+col ]

delete []visited ;
```
9. 链表和树的结构体 
10. deque 是双端队列 queue是单端队列 
```
queue 基本操作

push(x) 将x压入队列的末端

pop() 弹出队列的第一个元素(队顶元素)，注意此函数并不返回任何值

front() 返回第一个元素(队顶元素)

back() 返回最后被压入的元素(队尾元素)

empty() 当队列为空时，返回true

size() 返回队列的长度

```
11. 绝对值函数 abs（left-right）;
12. 用vector建堆
```
vector make_heap(res.begin(), res.end(),greater<int>()//建堆 最小堆 如果是最大堆就是 less<int>() 

//压入
res.push_back(res.begin(), res.end())//将新元素放在堆最后
push_heap()//(压入之后排序）调整堆
//弹出
pop_heap(res.begin(), res.end()) //弹出之前排序 //将最小元素放在堆最后 
res.pop_back() //删除堆中最后的元素（最小的元素）
```
13. 空的类所占内存是1 
    - 空类的实例不包含任何信息，但是我们在声明该类型的实例的时候，必须在内存中占有一定的空间，否则就无法使用。在vs中占一个字节。
    - 如果加了构造函数和析构函数，所占空间还是1。
    - 如果析构函数设为了虚函数，如果c++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，如果是在32位的机器上，一个指针占4字节的空间，sizeof(指针) =  4 。如果是64位的机器，一个指针占8字节的空间。
    
